# File类

### 三种构造方法

~~~java
// File的三种构造方法（里面的路径无论是什么都会进去）
		File f = new File("C:/Users/15524/桌面"); // 只有一个String
		File f2 = new File("C:/Users/15524/桌面", "aaa.txt"); // 两个String,会用一个斜杆连接起来
		File f3 = new File(f, "aaa.txt"); // 一个File一个String，用一个斜杆连接起来
~~~



### 对文件及文件夹的创建和删除

~~~java
// 对文件进行操作
		File f = new File("C:/Users/15524/桌面/aaa.txt");

		// 创建文件
		boolean b = f.createNewFile(); // 无则创建，有则不创建
		System.out.println(b);

		// 删除文件
		boolean c = f.delete(); // 直接删除，不进入回收站，慎用
		System.out.println(c);

		
		
		
		
		// 对文件夹进行操作
		File f2 = new File("C:/Users/15524/桌面/aaa");

		// 创建文件夹
		boolean d = f2.mkdir(); // 无法一次性创建多重文件夹
		System.out.println(d);

		// 删除文件夹
		boolean e = f2.delete(); //删除文件夹时只有文件夹为空才能删除
		System.out.println(e);

		// 创建多重文件夹
		File f3 = new File("C:/Users/15524/桌面/aaa/aa/a");
		boolean a = f3.mkdirs();
		System.out.println(a);
~~~



~~~java
File f = new File("C:/Users/15524/桌面/aaa.txt");

		f.createNewFile();

		//f.delete(); // 执行到就立刻删除

		f.deleteOnExit(); // 在虚拟机结束后才执行删除操作

		System.out.println("输入一个数之后退出");
		new Scanner(System.in).nextInt();
~~~





### 判断

~~~java
File f = new File("C:/Users/15524/桌面/aaa.txt");
		boolean b;

		// 判断此抽象路径的文件夹或文件是否存在
		b = f.exists();
		System.out.println(b);

		// 判断此抽象路径表示的文件是否是一个标准文件
		b = f.isFile();
		System.out.println(b);

		// 判断此抽象路径名表示的文件是否是一个文件夹
		b = f.isDirectory();
		System.out.println(b);

		// 判断此抽象路径表示的文件是否是一个隐藏文件
		b = f.isHidden();
		System.out.println(b);

		// 判断此抽象路径是否是绝对路径
		b = f.isAbsolute();
		System.out.println(b);
~~~



### 获取属性

~~~java
File f = new File("aaaa.txt"); // 相对与当前项目
		System.out.println(f.createNewFile());

		// 获取此抽象路径名表示的文件的长度
		long length = f.length();
		System.out.println(length);

		// 获取返回由此抽象路径名表示的文件或目录的名称。
		// 该名称是路径名名称序列中的最后一个名称。如果路径名名称序列为空，则返回空字符串
		String name = f.getName();
		System.out.println(name);

		// 将此抽象路径名转换为一个路径名字符串
		String path = f.getPath(); // 获取的是创建f是输入的字符串
		System.out.println(path);

		// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。
		String parent = f.getParent();
		System.out.println(parent);

		// 返回此抽象路径名的绝对路径名字符串
		String absolutePath = f.getAbsolutePath();
		System.out.println(absolutePath);

		// 返回此抽象路径名表示的文件最后一次被修改的时间
		long lastModified = f.lastModified();
		System.out.println(lastModified); // 得到的long类型的一个毫秒值
		// 将其转换成正常格式
		System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(lastModified)));

System.out.println("------------");

		// 获取抽象路径下的所有文件和文件夹
		File f1 = new File("E:/Space");
		String[] list = f1.list();
		for (String str : list) {
			System.out.println(str);
		}

		// 获取抽象路径下的文件和文件夹的绝对路径，注意返回值是File
		File[] ff = f1.listFiles();
		for (File f2 : ff) {
			System.out.println(f2);
		}

		System.out.println("---------------");

		// 只输出文件
		for (File f2 : ff) {
			if (f2.isFile()) {
				System.out.println(f2);
			}
		}
~~~

练习：输出抽象路径内的所有文件，遇到文件夹则不输出，但是要输出它里面的文件

~~~java
public static void main(String[] args) {
		File f = new File("E:\\java\\javase");

		File[] list = f.listFiles();
		Printable(list);
	}

	private static void Printable(File[] list) {
		for (File ff : list) {
			if (ff.isFile()) {
				System.out.println(ff);
			} else {
				Printable(ff.listFiles());
			}
		}

	}	//遍历的内容太多，eclipse的控制台显示不全，并非没有遍历到
		//即使文件是隐藏的，也能遍历出来
~~~



### 文件过滤器

在遍历文件时可以过滤不想要的文件，只获得想要的文件

~~~java
public static void main(String[] args) throws IOException {
		File f = new File("E:\\java\\javase\\01.Java语言概述及开发环境\\01.上课视频");
		File[] list = f.listFiles(new FilenameFilter() { 
// 使用listFiles方法时，加一个过滤器，规则自定义，可以对抽象路径的文件夹内的文件进行过滤 

// 还有一个过滤器，FileFilter,规则自定义，功能一样。两者的不同在于实现原理不一样，FilenameFilter是对文件名进行操作，重写的方法有两个参数；FileFilter是对文件来进行操作，重写的方法只有一个参数

			@Override
			public boolean accept(File dir, String name) {
				return name.endsWith(".mp4");
			}
		});
		for (File f1 : list) {
			System.out.println(f1);
		}

	}
~~~

而如果需要对所有文件进行过滤，则应使用其他方法

~~~java
public static void main(String[] args) {
		File f = new File("E:\\java\\javase");

		File[] list = f.listFiles();
		String msg = "^(.*" + "java" + ".*)$";
		Printable(list, msg);
	}

	private static void Printable(File[] list, String msg) {
		for (File ff : list) {
			if (ff.isFile()) {
				if (ff.getName().matches(msg)) {
					System.out.println(ff);
				}
			} else {
				Printable(ff.listFiles(), msg);
			}
		}

	}
~~~

可以使用正则对遍历出来的文件进行过滤；还可以使用String的其他方法或自己定义其他方法





# IO流

### 什么是IO流

​	流是一串连续不断的数据的集合。数据写入可以是一段一段地想数据流管道中写入数据，这些数据断会按先后顺序形成一个长的数据流，看不到数据流在写入时的分段情况，每次可以读取其中的任意长度的数据，但只能先读取前面的数据后，在读取后面的数据。不管写入时是将数据分多次写入，还是作为一个整体一次写入，读取时的效果都是完全一样的。



程序从输入流读取数据源。数据源包括键盘、文件、网络等，即使将数据源读入到陈故乡的通信通道

程序想输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道





### 流的分类

按流向分：输入流和输出流

​		输入流：只能从中读取数据

​		输出流：只能向其写入数据

按操作数据单元分：字节流和字符流

​		字节流：操作的数据单元是8位的字节

​		字符流：操作的数据单元是16位的字节

按流的角色分：节点流和处理流

​		节点流：可以从/向一个特定的IO设备（磁盘、网络等）读/写数据，也成为低级流

​		处理流：用于一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，也称为高级流





### IO流的操作

所有的流都是同样的使用步骤

1. 使用File定位文件
2. 创建IO流对象
3. 进行读或写操作
4. 关闭IO流



#### 字节输出流基本操作

~~~java
public static void main(String[] args) throws IOException {
		// 1.使用File类定位一个文件
		String path = "src/ioliu/aaa.txt";
		File f = new File(path);

		// 2.创建IO流对象
		// 因为是对文件写入数据，所以用父类是OutputStream，子类是FileOutputStream
//		OutputStream os = new FileOutputStream(f);	//这样进行的写操作是覆盖，实际是执行完执行完这行代码后文件存在是将文件内容清空
		OutputStream os = new FileOutputStream(f, true); // true参数表明写操作是追加

		// 3.进行读/写操作
		byte[] b = "hello,world!\r".getBytes(); // \n和\r都可以换行，\r是保证其他系统也能换行
		os.write(b);

		// 4.关闭资源
		os.close();
	}
~~~

练习：要求：讲一个学生的基本信息（姓名 密码 手机）保存到记事本，一条信息一行

~~~java
public static void main(String[] args) throws IOException {
		String path = "src/ioliu/student.txt";
		File f = new File(path);

		OutputStream os = new FileOutputStream(f, true);

		System.out.println("请输入学生信息（姓名 密码 手机）：");
		String str = new Scanner(System.in).nextLine() + "\r";//在接受到的字符串后面加换行
		byte[] b = str.getBytes();
		os.write(b);

		os.close();
	}
~~~

追加模式是指执行此次程序时不改动文件的内容往后面添加数据，如果不是追加模式，则此次执行写入的数据会覆盖掉原来的所有内容。**注意：**执行**一次**程序时，如果有多个写的动作，数据是追加的，即使不是在追加模式下



#### 字节输入流基本操作

~~~java
public static void main(String[] args) throws IOException {
		File f = new File("src/ioliu/student.txt");

		InputStream is = new FileInputStream(f);

		// 创建一个byte数组存储文件数据
		byte[] b = new byte[(int) f.length()];
		// 将数据读入到数组中
		is.read(b);

		// 将数组内容转换成字符串输出
		String str = new String(b);
		System.out.println(str);

		is.close();
	}
~~~

从字节流可以看出，字节流用来操作字符串很麻烦，需要转来转去。使用字符流就方便许多



#### 字符输入输出流

~~~java
public static void main(String[] args) throws IOException {
		File f = new File("src/ioliu/student.txt");

		Reader r = new FileReader(f);

		// 读取数组
		// 需要一个char类型数组存储数据
		char[] a = new char[(int) f.length()];
		r.read(a);

//		System.out.println(a);	//可以直接输出a，但他不是字符串，最好是先转成字符串再输出
		String str = new String(a);
		System.out.println(str);

		r.close();

	}

	private static void test() throws IOException {
		Writer w = new FileWriter("src/ioliu/student.txt", true); // 追加数据

		w.write("Hello,World!\r");

		w.close();
	}
~~~

以上输入流中读取的操作有弊端，如果读取的文件过大，那么用来存储的数组就会创建的很大，明显是不合理的

所以一般采取下面的方法

##### 循环读取

字节输入流：

~~~java
public static void main(String[] args) throws IOException {
		File f = new File("src/ioliu/student.txt");
		InputStream is = new FileInputStream(f);

		// 定义一个用来存储读取到的数据，数组长度不能太小，
		// 因为是按特定字节数读取的，如果数据中有中文，
		// 读取时中文的数据被分成两次读取，会造成乱码
		byte[] b = new byte[1024];
		int len;
		// 因为每次读取数据后都要拼接字符串，所以不用String
		StringBuilder str = new StringBuilder();
		while ((len = is.read(b)) != -1) { // 处于文件末尾没有字节可读，，read返回-1
			str.append(new String(b, 0, len)); // 从0开始，在b数组中复制len个字符转为字符串
		}
		System.out.println(str);
	}
~~~

字符输入流：

~~~java
public static void main(String[] args) throws IOException {
		File f = new File("src/ioliu/student.txt");
		Reader is = new FileReader(f);

		char[] b = new char[1024]; // 即使数组长度为1，中文也不会出现乱码
		int len;

		StringBuilder str = new StringBuilder();
		while ((len = is.read(b)) != -1) {
			str.append(new String(b, 0, len));
		}
		System.out.println(str);
	}
~~~



练习拷贝一个MP4文件

1.选定字节流，不能用字符流

2.先读取，读取到的同时将其写到桌面

~~~java
public static void main(String[] args) throws IOException {
		// 定位要拷贝的文件
		File f = new File("E:/java/javase/10.IO流/01.上课视频/01.File的介绍及基本操作.mp4");

		// 字节流读取准备
		InputStream is = new FileInputStream(f);
		byte[] b = new byte[1024]; // 用来存储读取的数据
		int len;// 用来记录每次读取到的字节数

		// 字节流写入准别
		File f2 = new File("C:/Users/15524/桌面/测试.mp4"); // 会自动创建文件，文件夹不会
		OutputStream os = new FileOutputStream(f2, true);// 注意调成追加模式

		// 循环读取数据，并将数据写入指定文件
		while ((len = is.read(b)) != -1) {
			os.write(b, 0, len);
			// 最好不要直接使用os.write(b);
			// 因为最后一次读取数据时可能不足1024
			// 然后又将整个b数组写入到文件中
			// 就会导致新文件多出一段数据
		}

		// 关闭资源
		is.close();
		os.close();
	}
~~~

可以将其封装成一个方法，两个参数，src（源文件地址）和dsrc（目标位置）



#### 正确关闭流的方式

~~~java
//只要new出对象，这个流就会存在内存中
InputStream is = new FileInputStream(f);
.....
//在之前的操作中都是完成操作后直接关闭资源
is.close();
//但是，这样并不能完全保证流能被关闭，这种方式是不合理的
~~~

应该使用下面这种操作方式

~~~java
InputStream is =null;	//因为要在finally中使用is，所以要定义到外面
try{
    is=new FileInputStream(f);
    ...
}catch(...){
    ...
}finally{
    try{
        if(is!=null)	//如果没创建出流，就不能执行关闭方法
        is.close();
    }catch(IOException e){
        e.printStackTrace();
    }
}
~~~

##### JDK1.7之后 关闭流的新特性

将定义流的语句放入try（）的小括号内

~~~java
try(InputStream is = new FileInputStream(f);){
    ...
}catch(...){
    ...
}
~~~







### 处理流

处理流的功能：隐藏底层设备上**节点流**（之前使用的都是节点流）的差异，并对外提供更加方便的输入/输出方法



使用处理流的典型思想是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的IO设备、文件交互。（这里有使用到装饰设计模式的思想）



实际识别处理流很简单，只要 流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流；而所有节点流都是直接以物理IO节点作为构造器参数



* 好处：**性能的提高**，主要是以增加缓冲的方式来提高输入/输出的效率（。比如我们用程序和记事本交互时，是点对点的交流，每次读写数据都要建立双方之间的链接，执行完操作后 又关闭链接，这样在交互大文件且一次传输的数据较少时，就会浪费资源。我们可以在这两者之间增加一个缓冲区，程序将要写入的数据先写入缓冲区，之后再一次性将缓冲区的内容写入记事本，这样就避免了频繁的读写硬盘，减少了资源的开销。好比生产商品的厂商，不会直接将商品麦给顾客，因为这样需要花费额外的资源来应对顾客，这些资源不如用在继续生产商品上；所以都会将商品统一先给代理商，再由代理商卖给顾客）

  **操作的简便**：处理流提供了一系列便携的方法来**一次性**输入/输出大批量的内容。

  处理流可以”嫁接“在任何已存在的流的基础上，这就允许Java程序采用相同的代码、透明的方式来访问不同的输入/输出设备的数据流





#### 字节缓冲流

~~~java
// 字节缓冲输入流
	private static void bufferedInput() {
		try (InputStream is = new FileInputStream("aaa.txt"); // 在try的()里创建流就不用手动关闭了
				BufferedInputStream bis = new BufferedInputStream(is);) {
			byte[] b = new byte[1024];
			int len;
			while ((len = bis.read(b)) != -1) {
				System.out.println(new String(b, 0, len));
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// 字节缓冲输出流
	private static void bufferedOutput() {
		// 创建一个节点流，然后用处理流包装起来再使用
		try (OutputStream os = new FileOutputStream("aaa.txt"); // 在try的()里创建流就不用手动关闭了
				BufferedOutputStream bos = new BufferedOutputStream(os);) {
			bos.write("hello,world".getBytes());

		} catch (Exception e) {
			e.printStackTrace();
		}
	}
~~~

步骤和节点流基本一致。从代码上看不出有什么不同，但实际上使用缓冲流的效率更高



练习：分别用节点流和缓冲流拷贝一个MP4文件，每次读取1kb（太大差距会减小，因为读写硬盘次数会变得接近），分别输出其用时

~~~java
public static void main(String[] args) {
		File f = new File("E:\\java\\javase\\10.IO流\\01.上课视频\\01.File的介绍及基本操作.mp4");

		// 节点流
		try (InputStream is = new FileInputStream(f);
				OutputStream os = new FileOutputStream(new File("C:/Users/15524/桌面/copy.mp4"));) {
			byte[] b = new byte[1024];
			int len;
			// 获取当前时间戳
			long start = System.currentTimeMillis();
			while ((len = is.read(b)) != -1) {
				os.write(b, 0, len);
			}
			long end = System.currentTimeMillis();
			System.out.println("节点流的耗时：" + (end - start));

		} catch (Exception e) {
			e.printStackTrace();
		}

		// 处理流
		try (InputStream is = new FileInputStream(f);
				BufferedInputStream bis = new BufferedInputStream(is);
				OutputStream os = new FileOutputStream(new File("C:/Users/15524/桌面/copy.mp4"));
				BufferedOutputStream bos = new BufferedOutputStream(os);) {
			byte[] b = new byte[1024];
			int len;
			// 获取当前时间戳
			long start = System.currentTimeMillis();
			while ((len = bis.read(b)) != -1) {
				bos.write(b, 0, len);
			}
			long end = System.currentTimeMillis();
			System.out.println("处理流的耗时：" + (end - start));

		} catch (Exception e) {
			e.printStackTrace();
		}

	}
~~~

结果：还是比较明显的

~~~java
节点流的耗时：2844
处理流的耗时：454
~~~

一次性读取的数据越少，差距越大





##### 装饰模式

装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。

**使用场景：** 1、扩展一个类的功能。 2、动态增加功能，动态撤销。

**注意事项：**可代替继承。





#### 字符缓冲流

字符缓冲输入流特有成员方法：

`public void newLine()` : 写一行行分隔符，由系统属性定义符号。

换行：换行符号

  windows ：\r\n
  linux ：/n
  mac ：/r

~~~java
public static void main(String[] args) {
		// 字符缓冲输出流
		try (Writer w = new FileWriter(new File("aaa.txt"), true); BufferedWriter bw = new BufferedWriter(w);) {
			w.write("hello,world\r");
		} catch (Exception e) {
			e.printStackTrace();
		}

		// 字符缓冲输入流
		try (Reader r = new FileReader(new File("aaa.txt")); BufferedReader br = new BufferedReader(r);) {
			// 使用Reader循环读取时需要用数组先存储再输出
			// 但是，BufferedReader增加了一个好用的方法
			// readLine，读取一行，以\n或\r作为结束，如果没读到数据了，则返回null
			StringBuilder sb = new StringBuilder();
			String str;
			while ((str = br.readLine()) != null) {
				sb.append(str + "\r"); // 因为readLine读取到换行符就结束，所以我们要手动增加换行符
			}
			System.out.println(sb);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
~~~

练习：用字符缓冲流和字符流分别拷贝一个txt文件，并输出耗时

~~~java
public static void main(String[] args) {
		try (Reader r = new FileReader(new File("aaa.txt"));
				BufferedReader br = new BufferedReader(r);
				Writer w = new FileWriter(new File("bbb.txt"));
				BufferedWriter bw = new BufferedWriter(w);) {

			// 字符流拷贝txt文件
			char[] c = new char[1];
			int len;
			long start = System.currentTimeMillis();
			while ((len = r.read(c)) != -1) {
				w.write(c, 0, len);
			}
			long end = System.currentTimeMillis();
			System.out.println("字符流耗时" + (end - start));

			
			
			// 字符缓冲流拷贝txt文件
			StringBuilder sb = new StringBuilder();
			String str;
			long start2 = System.currentTimeMillis();
			while ((str = br.readLine()) != null) {
				sb.append(str + "\r");
			}
			long end2 = System.currentTimeMillis();
			System.out.println("字符缓冲流耗时" + (end2 - start2));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
~~~

结果：（）

~~~java
字符流耗时604
字符缓冲流耗时0
~~~



### 转换流

属于字符流，是字节流通向字符流的桥梁

#### InputStreamReader

将字节输入流转换成字节输入流

从记事本读取数据时，假设记事本是ASCII编码，而开发工具是UTF-8，则会出现中文乱码的问题

这时就需要使用转换流，将字节流转换成字符流的同时，可以设置读取的编码集

~~~java
public static void main(String[] args) {
		try (InputStream is = new FileInputStream(new File("C:/Users/15524/桌面/aaa.txt"));
				InputStreamReader isr = new InputStreamReader(is, "gbk");) { // 设置编码集,不区分大小写
			char[] c = new char[1024];
			int len;
			while ((len = isr.read(c)) != -1) {
				System.out.println(new String(c, 0, len));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
~~~



#### OutputStreamWriter

将字节输出流转换成字符输出流

~~~java
public static void main(String[] args) {
		try (OutputStream os = new FileOutputStream(new File("C:/Users/15524/桌面/bbb.txt"), true);
				OutputStreamWriter osw = new OutputStreamWriter(os, "Gbk");) {//不设置的话，默认和开发工具一致
			osw.write("你好，世界！");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
~~~

windows的记事本为ANSI编码时，不能使用ASCII编码输入，eclipse也不能设置输出ANSI编码，所以使用GBK











# 对象流（序列化流）

序列化：将对象保存到文件中

反序列化：从文件中读取对象



* 要想完成对象的输入和输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）
* 使用对象输出流输出序列化对象的步骤被称为序列化，使用对象输入流读入对象的过程，被称为反序列化



程序—————（ObjectOutputStream）—————序列化对象——————（ObjectInputStream）——————程序

​			——————————————>序列化										——————————————>反序列化





## 对象输出输入流

首先输出对象的类必须实现Serialzable接口，否则会报以下错误：不能序列化

![序列化错误](E:%5Cjava%5Cjavase%5C%E7%AC%94%E8%AE%B0%5C%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0%5C%E5%BA%8F%E5%88%97%E5%8C%96%E9%94%99%E8%AF%AF.jpg)

实现了这个接口就能使用对象输出流输出该类对象了

~~~java
public class SerialzableDemo {
	public static void main(String[] args) {
		try (OutputStream os = new FileOutputStream(new File("student.txt"));
				ObjectOutputStream oos = new ObjectOutputStream(os);) {

			Student stu = new Student("张三", "123", "男", 28, 55);
			oos.writeObject(stu);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Student implements Serializable {
//	//和序列化有关的常量，有没有都行，加了就不会报警告
//	private static final long serialVersionUID = 1L;
	private String name;
	private String password;
	private String sex;
	private int age;
	private int score;

	public Student() {
		super();
	}

	public Student(String name, String password, String sex, int age, int score) {
		super();
		this.name = name;
		this.password = password;
		this.sex = sex;
		this.age = age;
		this.score = score;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public int getScore() {
		return score;
	}

	public void setScore(int score) {
		this.score = score;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", password=" + password + ", sex=" + sex + ", age=" + age + ", score=" + score
				+ "]";
	}

}
~~~

这样对象的数据就保存下来了，但在记事本上是看不懂的

同样可以将其读取出来

~~~java
try (InputStream os = new FileInputStream(new File("student.txt"));
				ObjectInputStream oos = new ObjectInputStream(os);) {
			Student s1 = (Student) oos.readObject();
			System.out.println(s1);

		} catch (Exception e) {
			e.printStackTrace();
		}
~~~



![Serialzable接口](E:%5Cjava%5Cjavase%5C%E7%AC%94%E8%AE%B0%5C%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0%5CSerialzable%E6%8E%A5%E5%8F%A3.jpg)

Serialzable接口（序列化接口）什么都没有，这样的接口是标记接口，有这个标记就能进行序列化。

之前使用String输出时能直接输出，是因为String也实现了这个序列化接口



## 循环读取对象时的问题

~~~java
try (OutputStream os = new FileOutputStream(new File("student.txt"),true);	//追加
				ObjectOutputStream oos = new ObjectOutputStream(os);) {

			Student stu = new Student("李四", "123", "男", 28, 55);
			oos.writeObject(stu);
		} catch (Exception e) {
			e.printStackTrace();
		}
~~~

如果在写入数据时用的是追加模式，每次只写入一个，执行多次后文件中确实会有数据新增，但读取读第二个对象时则会报错

~~~java
try (InputStream os = new FileInputStream(new File("student.txt"));
				ObjectInputStream oos = new ObjectInputStream(os);) {
			Student s1 = (Student) oos.readObject();
			Student s2 = (Student) oos.readObject();//报错
			System.out.println(s1);
			System.out.println(s2);
~~~

但如果是一次性写入多个对象，则读第二个对象时不会报错。

~~~java
try (OutputStream os = new FileOutputStream(new File("student.txt"), true);
				ObjectOutputStream oos = new ObjectOutputStream(os);) {

			Student stu = new Student("张三", "123", "男", 28, 55);
			Student stu2 = new Student("李四", "123", "男", 28, 55);
			Student stu3 = new Student("王五", "123", "男", 28, 55);
			oos.writeObject(stu);
			oos.writeObject(stu2);
			oos.writeObject(stu3);

		} catch (Exception e) {
			e.printStackTrace();
		}
~~~

经测试，在追加模式下，第二次写入的数据位置会与第一次写入的位置不一样，可能就是导致读取时错误的原因。所以不能使用追加模式。只能将数据一次性写入



例如上面的第二次写入，一次性写入三个对象后，可以正确读出三个对象

~~~java
try (InputStream os = new FileInputStream(new File("student.txt"));
				ObjectInputStream oos = new ObjectInputStream(os);) {
			Student s1 = (Student) oos.readObject();
			Student s2 = (Student) oos.readObject();
			Student s3 = (Student) oos.readObject();
			System.out.println(s1);
			System.out.println(s2);
			System.out.println(s3);

		} catch (Exception e) {
			e.printStackTrace();
		}
~~~

如果继续读取，则会报异常，这个异常就是说没有东西可读了

 我们读取时数据肯定是用循环来读，如下：

~~~java
try (InputStream os = new FileInputStream(new File("student.txt"));
				ObjectInputStream oos = new ObjectInputStream(os);) {
			Student stu;
			while ((stu = (Student) oos.readObject()) != null) {
				System.out.println(stu);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
~~~

前面三个数据依旧能读出来，但会报异常，因为readObject()读不到对象时返回的不是null（序列化流不是以null结束的）

所以我们在写入对象时，最后要加一个空对象，这样使用上面的循环读取时就不会报错了

~~~java
try (OutputStream os = new FileOutputStream(new File("student.txt"));
				ObjectOutputStream oos = new ObjectOutputStream(os);) {

			Student stu = new Student("张三", "123", "男", 28, 55);
			Student stu2 = new Student("李四", "123", "男", 28, 55);
			Student stu3 = new Student("王五", "123", "男", 28, 55);
			oos.writeObject(stu);
			oos.writeObject(stu2);
			oos.writeObject(stu3);
			oos.writeObject(null);

		} catch (Exception e) {
			e.printStackTrace();
		}
~~~



案例：将学生管理系统所有信息永久化保存（三层架构）



## 1.7 transient关键字

### 1.7.1 概述

- 在一些特殊的场景下，如果一个类里包含的某些实例变量是敏感信息，例如银行账户信息等，这时不希望系统将该实例变量值进行序列化 ;或者某个实例变量的类型是不可序列化的。通过在实例变量前面使用 transient关键字修饰，可以指定 Java序列化时无须理会该实例变量 。

### 1.7.2 特点

- transient只能修饰成员变量
- 指定 Java序列化时无须理会该实例变量 

### 1.7.3 用法

- 由于本程序中的 Person 类的 age实例变量使用 transient 关键宇修饰，所以反序列后无法获取age值，输出结果为 0 。  



## 1.8 自定义序列化

### 1.8.1 概述

- 程序员可以完全获得对序列化机制的控制 ，可以自主决定哪些实例变量需要序列化 ，需要怎样序列化 。   
- 程序员可以完全获得对反序列化机制的控制，可以自主决定需要反序列化哪些实例变量，以及如何进行反序列化 。

### 1.8.2 重写方法

- private void writeObject(java.io.ObjectOutputStream out)throws IOException

  ~~~ 
  writeObject方法负责写入特定类的实例状态，以便相应的readObject方法可以恢复它 。 通过重写
  该方法，程序员可以完全获得对序列化机制的控制 ，可以自主决定哪些实例变量需要序列化，需要怎样序列化。
  ~~~

- private void readObject(java.io.ObjectInputStream in)throws IOException, ClassNotFoundExccption;

  ~~~ 
  readObject方法负责从流中读取并恢复对象实例变量 ，通过重写该方法，程序员可以完全获得对反序列化机制的控制，可以自主决定需要反序列化哪些实例变量 ，以及如何进行反序列化 。 
  ~~~

### 1.8.3 用法

~~~ java
public class Person implements java.io.Serializable
{
    private String name;
    private int age;
    // 注意此处没有提供无参数的构造器!
    public Person(String name , int age)
    {
        System.out.println("有参数的构造器");
        this.name = name;
        this.age = age;
    }
    // 省略name与age的setter和getter方法

    // name的setter和getter方法
    public void setName(String name)
    {
        this.name = name;
    }
    public String getName()
    {
        return this.name;
    }

    // age的setter和getter方法
    public void setAge(int age)
    {
        this.age = age;
    }
    public int getAge()
    {
        return this.age;
    }

    private void writeObject(java.io.ObjectOutputStream out)
            throws IOException
    {
        // 将name实例变量的值反转后写入二进制流
        out.writeObject(new StringBuffer(name).reverse());
        out.writeInt(age);
    }
    private void readObject(java.io.ObjectInputStream in)
            throws IOException, ClassNotFoundException
    {
        // 将读取的字符串反转后赋给name实例变量
        this.name = ((StringBuffer)in.readObject()).reverse()
                .toString();
        this.age = in.readInt();
    }
}

~~~



# 2. NIO

## 2.1 概述

- 当 BufferedReader 读取输入流中的数据时，如果没有读到有效数据，程序将在此处阻塞该线程的执行(使用 InputStream 的 read（）方法从流中读取数据时，如果数据源中没有数据，它也会阻塞该线程) ，也就是前面介绍的输入流、输出流都是阻塞式的输入、输出 。 不仅如此，传统的输入流、输出流都是通过字节的移动来处理的(即使不直接去处理字节流 ，但底层的实现还是依赖于字节处理) ，也就是说，面向流的输入/输出系统一次只能处理一个字节，因此面向流的输入/输出系统通常效率不高。  

## 2.2 什么是NIO

- Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。

## 2.3 Java NIO 与 IO 的主要区别

![image-20220805093623337](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO.png)

## 2.4 核心类

### Channel (通道)

- Channel 是对传统的输入/输出系统的模拟，在新IO系统中所有的数据都需要通过通道传输; Channel 与传统的 InputStream、 OutputStream最大的区别在于它提供了 一个 map方法，通过该 map方法可以直接将" 一块数据"映射到内存中 。

###  Buffer (缓冲)

- Buffer 可以被理解成一个容器，它的本质是 一个数组，发送到 Channel 中的所有对象都必须首先放到 Buffer 中， 而从 Channel 中读取的数据也必须先放到 Buffer中。

## 2.5 Buffer类用法

### 2.5.1 简介

- 什么缓冲区
  - 一个用于特定基本数据类型的容器

### 2.5.2 作用

- Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。

### 2.5.3 基本属性

- 容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。

- 限制 (limit) ：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。

- 位置 (position)： ：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制

![image-20220805093702618](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO2.png)

### 2.5.4 核心方法

![image-20220805093722119](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO3.png)

- 当使用 put（）和 get（）来访 问 Buffer 中的数据时，分为相对和绝对两种 
  - 相对（Relative）:从 Buffer的当前 position 处开始读取或写入数据， 然后将位置 （position） 的
    值按处理元素的个数增加。
  - 绝对（Absolute）: 直接根据索引向 Buffer 中读取或写入数据，使用绝对方式访问 Buffer 里 的
    数据时，并不会影响位置（position）的值 。

### 2.5.5 用法

~~~ java
package com.gec.nio用法;

import java.nio.CharBuffer;

public class NioMainTest {

    public static void main(String[] args) {

        // 创建Buffer
        CharBuffer buff = CharBuffer.allocate(8);    // ①
        System.out.println("capacity: "	+ buff.capacity());
        System.out.println("limit: " + buff.limit());
        System.out.println("position: " + buff.position());
        // 放入元素
        buff.put('a');
        buff.put('b');
        buff.put('c');      // ②
        System.out.println("加入三个元素后，position = "
                + buff.position());
        // 调用flip()方法
        buff.flip();	  // ③
        System.out.println("执行flip()后，limit = " + buff.limit());
        System.out.println("position = " + buff.position());
        // 取出第一个元素
        System.out.println("第一个元素(position=0)：" + buff.get());  // ④
        System.out.println("取出一个元素后，position = "
                + buff.position());
        // 取出第一个元素
        System.out.println("第二个元素(position=0)：" + buff.get());  // ④
        System.out.println("取出二个元素后，position = "
                + buff.position());
        // 调用clear方法
        buff.clear();     // ⑤
        System.out.println("执行clear()后，limit = " + buff.limit());
        System.out.println("执行clear()后，position = "
                + buff.position());
        System.out.println("执行clear()后，缓冲区内容并没有被清除："
                + "第三个元素为：" +  buff.get(2));    // ⑥
        System.out.println("执行绝对读取后，position = "
                + buff.position());

    }
}

~~~

![IO4](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO4.png)

![image-20220805093813308](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO5.png)

## 2.6 通道（Channel） 

### 2.6.1 简介

- Channel就是表示 IO 源与目标打开的连接，通过Channel可以将数据讲到缓冲区，也就是说Channel直接能够与缓冲区进行读、写操作

### 2.6.2 channel实现类

- Java 为 Channel 接口提供了 DatagramChannel 、 FileChannel 、 Pipe.SinkChannel 、 Pipe.SourceChannel 、SelectableChannel 、 ServerSocketChannel 、 SocketChannel 等实现类  

### 2.6.3 FileChannel用法

#### 简介

- 用于读取、写入、映射和操作文件的通道。

#### 常用方法

- Channel 中最常用的三类方法是 map（） 、 read（）和 write（），其中 map（）方法用于将 Channel 对应的部分或全部数据映射成 ByteBuffer; 而 read（）或 write（）方法都有一系列重载形式，这些方法用于从 Buffer中读取数据或向 Buffer 中写入数据 。
- map方法的方法签名为 : MappedByteBuffer map(FileChannel.MapMode mode, long position, long
  size ) 
  - 第 一 个参数执行映射时的模式，分别有只读 、 读写等模式 :
  - 第 二 个、第 三 个参数用于控制将Channel的哪些数据映射成 ByteBuffer 。

#### 实例

##### 全部映射实例

- 直接将 FileChannel 的全部数据映射成 ByteBuffer 的 效果

  ~~~ java
  package com.gec.filechannel用法;
  
  import java.io.File;
  import java.io.FileInputStream;
  import java.io.FileOutputStream;
  import java.io.IOException;
  import java.nio.MappedByteBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.charset.Charset;
  
  public class FileChannelTest {
  
      public static void main(String[] args)
      {
          File f = new File("FileChannelTest.java");
          try(
                  // 创建FileInputStream，以该文件输入流创建FileChannel
                  FileChannel inChannel = new FileInputStream(f).getChannel();
                  // 以文件输出流创建FileBuffer，用以控制输出
                  FileChannel outChannel = new FileOutputStream("a.txt")
                          .getChannel())
          {
               //将缓冲转换成数组后输出
  //        while ((len = fc.read(bb)) != -1) {
  //            String str = new String(bb.array(), 0, len);
  //            System.out.println(str);
  //            bb.clear();
  //
  //        }
              
              // 将FileChannel里的全部数据映射成ByteBuffer
              MappedByteBuffer buffer = inChannel.map(FileChannel
                      .MapMode.READ_ONLY , 0 , f.length());   // ①
              // 使用GBK的字符集来创建解码器
              //Charset charset = Charset.forName("GBK");
              // 直接将buffer里的数据全部输出
              outChannel.write(buffer);     // ②
              // 再次调用buffer的clear()方法，复原limit、position的位置
              buffer.clear();
        /*      // 创建解码器(CharsetDecoder)对象
              CharsetDecoder decoder = charset.newDecoder();
              // 使用解码器将ByteBuffer转换成CharBuffer
              CharBuffer charBuffer =  decoder.decode(buffer);
              // CharBuffer的toString方法可以获取对应的字符串
              System.out.println(charBuffer);*/
          }
          catch (IOException ex)
          {
              ex.printStackTrace();
          }
      }
  
  }
  
  ~~~

##### 用竹筒多次重复取水

- 习惯了传统IO的 " 用竹筒多次重复取水 " 的过程，或者担心 Channel 对应 的文件过大 

  ~~~ java
  package com.gec.filechannel用法;
  
  import java.io.FileInputStream;
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.CharBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.charset.Charset;
  import java.nio.charset.CharsetDecoder;
  
  public class ReadFile {
  
      public static void main(String[] args)
              throws IOException {
          // 创建文件输入流
          FileInputStream fis = new FileInputStream("ReadFile.java");
          // 创建一个FileChannel
          FileChannel fcin = fis.getChannel();
          // 定义一个ByteBuffer对象，用于重复取水
          ByteBuffer bbuff = ByteBuffer.allocate(256);
          // 将FileChannel中数据放入ByteBuffer中
          while( fcin.read(bbuff) != -1 )
          {
              // 锁定Buffer的空白区
              bbuff.flip();
              // 创建Charset对象
              Charset charset = Charset.forName("UTF-8");
              // 创建解码器(CharsetDecoder)对象
              CharsetDecoder decoder = charset.newDecoder();
              // 将ByteBuffer的内容转码
              CharBuffer cbuff = decoder.decode(bbuff);
              System.out.print(cbuff);
              // 将Buffer初始化，为下一次读取数据做准备
              bbuff.clear();
          }
      }
  }
  
  ~~~

## 2.7 编码解码

### 2.7.1 简介

- 计算机里的文件、数据 、图片文件只是一种表面现象，所有文件在底层都是二进制文件 ，即全部都是字节码。图片、音乐文件暂时先不说，对于文本文件而言，之所以可 以看到一个个的字符，这完全是因为系统将底层 的二进制序列转换成字符的缘故。在这个过程中涉及两个概念:编码C Encode ) 和解码 C Decode ) 

  ![image-20220805093924467](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO6.png)

![image-20220805093940101](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO7.png)

### 2.7.2 Charset类

#### 获取CharSet对象

- 一旦知道了字符集的别名之后 ， 程序就可 以调用 Charset 的 forNameO方法来创建对应的 Charset 对
  象 ， forNameO方法的参数就是相应字符集的别名。 例如如下代码 :  

  ~~~ java
  Charset cs = Charset.forName( "ISO-8859-1");
  Charset csCn = Charset.forName("GBK" );
  ~~~

#### 如何使用

- 获得了 Charset 对象之后 ， 就可 以通过该对象 的 newDecoder（） 、 newEncoder（）这两个方法分别返回CharsetDecoder 和 CharsetEncoder 对 象 ，代表该 Charset 的解码器和 编码器。调 用 CharsetDecoder 的 decode方法就可以将 ByteBuffer (字节序列 〉转换成 CharBuffer (字符序列 ) ， 调用 CharsetEncoder 的 encode方法就可以 将 CharBuffer 或 String (字符序 列 )转换成 ByteBuffer (字节序 列 ) 。 如 下程序使用了
  CharsetEncoder 和 CharsetDecoder 完成 了 ByteBuffer 和 CharBuffer 之间的转换 。

#### 核心方法

![image-20220805094003133](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IO8.png)

#### 用法

~~~ java
import java.nio.*;
import java.nio.charset.*;

public class CharsetTransform
{
	public static void main(String[] args)
		throws Exception
	{
		// 创建简体中文对应的Charset
		Charset cn = Charset.forName("GBK");
		// 获取cn对象对应的编码器和解码器
		CharsetEncoder cnEncoder = cn.newEncoder();
		CharsetDecoder cnDecoder = cn.newDecoder();
		// 创建一个CharBuffer对象
		CharBuffer cbuff = CharBuffer.allocate(8);
		cbuff.put('孙');
		cbuff.put('悟');
		cbuff.put('空');
		cbuff.flip();
		// 将CharBuffer中的字符序列转换成字节序列
		ByteBuffer bbuff = cnEncoder.encode(cbuff);
		// 循环访问ByteBuffer中的每个字节
		for (int i = 0; i < bbuff.capacity() ; i++)
		{
			System.out.print(bbuff.get(i) + " ");
		}
		// 将ByteBuffer的数据解码成字符序列
		System.out.println("\n" + cnDecoder.decode(bbuff));
	}
}

~~~









# 打印流

只有输出流，是输出最方便的流。主要包含字节打印流（PrintStream）和字符打印流（PrintWriter）。打印流提供了非常方便的打印功能，可以打印任何的数据类型（小数，整数，字符串等等）

一样可以将数据写入txt，也可以用来输出网页

## 3.5 重定向

### 3.5.1 重定向概念

- 有两种重写向输出
  - 标准输出
    - 默认的标准输出设备：控制台
  - 标准错误输出
    - 默认的标准输出设备：控制台（以红色字体方式输出）
- 标准输入
  - 默认的设备：键盘
- 上述重定向输入、输出都可以使用System类来描述

  - System.in
    - 描述标准输入（默认：键盘）
  - System.out
    - 描述标准输出（默认控制台）
  - System.err
    - 描述标准错误输出（默认控制台，以红色字体输出）

### 3.5.2 重定向用法

![image-20220805184130481](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/IOO.png)



~~~ java
package PrintStream实例;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

public class MainTest {

	public static void main(String[] args) throws IOException {
		
/*		System.out.println("hello world");
		System.err.println("java hello");*/
		//调用PrintStream的打印流将helloworld输出到控制器
		//重定向输出
		/*
		 * 标准输出:System.out配置
		 * 标准错误输出:System.err配置
		 * */
		/*
		 * 修改重定向设备：
		 * 	标准输出到a.txt
		 *  标准错误输出：b.txt
		 * 
		 */
		PrintStream consolePs=System.out;
		//创建一个PrintStream打印类，针对文件输出流进行打印写入操作
		FileOutputStream aFileOutptStream=new FileOutputStream(new File("a.txt"));
		PrintStream ps=new PrintStream(aFileOutptStream);
/*		ps.println("helloworld 1");
		ps.println("helloworld 2");
		ps.println("helloworld 3");*/
		
		ps.write(97);
		
		
		//创建一个PrintStream打印类，针对标准错误输出信息打印到b.txt
		/*FileOutputStream bFileOutptStream=new FileOutputStream(new File("b.txt"));
		PrintStream errorPs=new PrintStream(bFileOutptStream);
		
		//更改标准输出设备：从控制台---->a.txt文件
		System.setOut(ps);
		//更改标准错误输出设备：从控制台----->b.txt
		System.setErr(errorPs);
		
		System.out.println("helloworld");
		System.out.println("helloworld2");
		System.out.println("helloworld3");
		
		//还原默认的标准输出
		System.setOut(consolePs);
		
		System.out.println("helloworld4");
		System.out.println("helloworld5");
		System.out.println("helloworld6");
		
		//输出标准错误信息
		System.err.println("error helloworld 1");
		System.err.println("error helloworld 2");
		System.err.println("error helloworld 3");
		System.err.println("error helloworld 4");*/
		/*
		ps.println("helloworld");
		ps.println("aaaaaa");
		ps.println("bbbbb");
		ps.flush();
		ps.close();
		aFileOutptStream.close();
		*/

		

	}

}

~~~























# 内存流（参照点为内存）

输入和输出都是从文件中来的，当然，也可将输出的位置设置在内存上，
这就需要ByteArrayInputStream和ByteArrayOutputStream
ByteArray**InputStream**将内容**写入到内存**中，
ByteArray**OutputStream**将内存中的数据**读取**出来



例子，在内存中写和读数据

~~~java
public static void main(String[] args) throws IOException {

		// 直接就写进去了，因为默认就是写入内存，不用再指定位置
		InputStream is = new ByteArrayInputStream("hello,world".getBytes());

		OutputStream os = new ByteArrayOutputStream();

		int len;

		while ((len = is.read()) != -1) {
			// 将读取到的数据转换成大写
			os.write(Character.toUpperCase(len));
		}
		String str = os.toString();
		System.out.println(str);
	}
~~~









# 第三方IO流框架--------Commons-IO

Apache下免费的

使用步骤：

1. 解压文件
2. 在里面找到开发文件
3. 在eclipse的项目中new一个文件夹lib
4. 将开发包复制到lib中
5. 将开发包添加到库中：右击jar包，build path，add to build Path
6. 添加后就可以正常使用了



idea添加方法：项目结构-----》模块-------》依赖--------》点+，选择添加jar包------》找到jar包添加完成



FileUtil常用功能

~~~java
public static void main(String[] args) throws IOException {
		File file1 = new File("D:\\Test\\aa.txt");
		File file2 = new File("D:\\Test\\bb.txt");
		File fileDirectory = new File("D:\\Test");

		// 1.创建文件(获取文件)
		// 1.1创建文件
		// 1)从文件夹中获取指定文件
		File file = FileUtils.getFile(fileDirectory, "aa.txt");
		// 2)获取获取临时文件
		File tmpFile = FileUtils.getTempDirectory();
		// 3)获取临时文件路径
		String tmpFilePath = FileUtils.getTempDirectoryPath();
		// 4)获取用户文件
		File userFileDirectory = FileUtils.getUserDirectory();
		// 5)获取用户文件路径
		String userFileDirectoryPath = FileUtils.getUserDirectoryPath();

		// 1.2 创建文件夹
		// 1)强制创建文件夹
		FileUtils.forceMkdir(fileDirectory);
		// 2)强制创建父文件夹
		FileUtils.forceMkdir(file1);

		// 2删除文件
		// 2.1删除文件夹
		// 1)删除文件夹中的内容(包括子文件夹和子文件)
		FileUtils.cleanDirectory(new File("D:\\Test"));
		// 2)温和的删除文件,不抛出异常
		FileUtils.deleteQuietly(file1);
		// 3)强制删除文件
		FileUtils.forceDelete(file1);
		// 4)JVM退出时强制删除文件
		FileUtils.forceDeleteOnExit(file1);

		// 3修改文件
		// 3.1修改文件
		// 1)移动文件夹
		FileUtils.moveDirectory(file1, file2);
		// 3.2修改文件夹
		// 1)移动文件夹
		FileUtils.moveDirectory(file1, file2);
		// 2)将文件移到指定的文件夹
		FileUtils.moveFileToDirectory(file1, fileDirectory, true);
		// 3)移动文件或文件夹到指定的文件夹
		FileUtils.moveToDirectory(file1, fileDirectory, true);

		// 4.文件查找
		// 1)是否递归查找指定扩展名的文件
		String[] extensions = new String[] { "txt", "jpg", "png" };
		Collection<File> fileList = FileUtils.listFiles(fileDirectory, extensions, true);

		// 5.读取文件
		// 1)根据文件获取文件输入流
		FileInputStream fileInputStream = FileUtils.openInputStream(file1);
		// 2)读取文件到字节数组
		byte[] bytes = FileUtils.readFileToByteArray(file1);
		// 3)读取文件到字符串
		String fileContent = FileUtils.readFileToString(file1, "UTF-8");
		// 4)读取文件到集合中
		List<String> fileContentList = FileUtils.readLines(file1, "UTF-8");
		// 5)获取文件大小
		long fileSize = FileUtils.sizeOf(file1);

		// 6.写文件
		// 1)根据文件获取输出流
		FileOutputStream fileOutputStream = FileUtils.openOutputStream(file1);
		// 2)获取文件输出流并指定是否追加到文件中
		FileOutputStream fileOutputStream1 = FileUtils.openOutputStream(file1, true);
		// 3)将字节数组内容写到文件中,文件不存在时创建
		FileUtils.writeByteArrayToFile(file1, bytes);
		// 4)将字节数组内容写到文件中,文件不存在时创建,并指定是否追加
		FileUtils.writeByteArrayToFile(file1, bytes, true);
		// 5)将集合数据按行写到文件中
		FileUtils.writeLines(file1, fileContentList);
		// 6)将集合数据按行写到文件中,并指定是否追加
		FileUtils.writeLines(file1, fileContentList, true);
		// 7)将字符串写到文件中,并指定编码
		FileUtils.writeStringToFile(file, fileContent, "UTF-8");
		// 8)将字符串数据写到文件中,并指定编码和是否追加的方式
		FileUtils.writeStringToFile(file, fileContent, "UTF-8", true);

		// 7.复制文件
		// 7.1复制文件目录
		// 1)复制文件目录中的内容到另一个目录
		File fileDir = new File("D:\\Test");
		File destDir = new File("D:\\Test1");
		FileUtils.copyDirectory(fileDir, destDir);
		// 2)复制文件目录,并指定是否保存文件日期
		FileUtils.copyDirectory(fileDir, destDir, true);
		// 3)使用文件过滤器过滤文件
		FileUtils.copyDirectory(fileDir, destDir, new NameFileFilter("aa"));
		// 7.2复制文件
		// 1)复制文件
		FileUtils.copyFile(file1, file2);
		// 2)复制文件并指定是否保留文件日期
		FileUtils.copyDirectory(file1, file2, true);
		// 3)复制文件夹到目录
		FileUtils.copyFileToDirectory(file1, destDir);
		// 4)将url资源复制到指定文件
		FileUtils.copyURLToFile(new URL(""), file);

		// 8.文件过滤

		// 9.文件比较与判断
		// 1)比较文件内容是否相同
		System.out.println(FileUtils.contentEquals(file1, file2));
		// 2)判断一个文件夹是否包含另外一个文件夹
		System.out.println(FileUtils.directoryContains(file1, file2));
		// 3)判断文件是否新文件
		System.out.println(FileUtils.isFileNewer(file1, new Date()));
		System.out.println(FileUtils.isFileOlder(file1, new Date()));
		// 4)判断文件和另外一个文件比是否是新的
		System.out.println(FileUtils.isFileNewer(file1, file2));
		System.out.println(FileUtils.isFileOlder(file1, file2));

		// 10.涉及文件操作的数据转换
		// 1)将文件集合转换为文件数组
		File[] fileArray = FileUtils.convertFileCollectionToFileArray(fileList);
		// 2)将url资源转换为文件对象
		File newUrlFiles = FileUtils.toFile(new URL(""));
		// 3)将多个url资源转换为文件数组
		URL[] urls = new URL[] {};
		File[] newUrlFiles1 = FileUtils.toFiles(urls);
		// 4将文件数组转化为url资源
		URL[] urls1 = FileUtils.toURLs(newUrlFiles1);

		// 11.文件迭代
		LineIterator iterator = FileUtils.lineIterator(file1, "UTF-8");
		while (iterator.hasNext()) {
			System.out.println(iterator.next());
		}
	}
~~~



FilenameUtil常用方法

~~~java
public class Commons_ioTest2 {
	public static void main1(String[] args) throws IOException {
		  /**
		   * 
		   * 
		   * 
		   * 
         * 文件相关俗语
         * C:\dev\project\file.txt
         * the prefix   C:\
         * the path     dev\project\
         * the full     C:\dev\project\
         * the name     file.txt
         * the base     file
         * the extension    txt
         * 
         * 
         * 
         * 
         * 
         * 
         */
		// 1判断父目录是否包含子元素(文件或目录)
		System.out.println(FilenameUtils.directoryContains("C:\\Users\\Administrator\\Downloads",
				"C:\\Users\\Administrator\\Downloads\\oo.png"));// true

		// 2判断两个文件名是否相等
		System.out.println(FilenameUtils.equals("C:\\Users\\Administrator\\Downloads",
				"C:\\Users\\Administrator\\Downloads\\00.png"));// false

		// 3两个文件名标准化后判断是否相等
		System.out.println(FilenameUtils.equalsNormalized("C:\\Users\\Administrator\\Downloads",
				"C:\\Users\\Administrator\\Downloads\\00.png"));// false

		// 4获取文件基本名
		System.out.println(FilenameUtils.getBaseName("C:\\Users\\Administrator\\Downloads\\test00.png"));// test00

		// 5获取文件扩展名
		System.out.println(FilenameUtils.getExtension("C:\\Users\\Administrator\\Downloads\\test00.png"));// png

		// 6获取文件完整路径,不含文件名
		System.out.println(FilenameUtils.getFullPath("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:\Users\Administrator\Downloads\

		// 7获取文件不含结尾分隔符的完整路径,不含文件名
		System.out.println(FilenameUtils.getFullPathNoEndSeparator("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:\Users\Administrator\Downloads

		// 8获取单独的文件名和后缀
		System.out.println(FilenameUtils.getName("C:\\Users\\Administrator\\Downloads\\test00.png")); // test00.png

		// 9获取不含前缀的完整文件路径,不含文件名
		System.out.println(FilenameUtils.getPath("C:\\Users\\Administrator\\Downloads\\test00.png"));// Users\Administrator\Downloads\

		// 10获取不含前缀和结尾分隔符的完整文件路径,不含文件名
		System.out.println(FilenameUtils.getPathNoEndSeparator("C:\\Users\\Administrator\\Downloads\\test00.png"));// Users\Administrator\Downloads

		// 11获取文件路径前缀
		System.out.println(FilenameUtils.getPrefix("C:\\Users\\Administrator\\Downloads\\test00.png"));// C;\

		// 12获取文件路径前缀长度
		System.out.println(FilenameUtils.getPrefixLength("C:\\Users\\Administrator\\Downloads\\test00.png"));// 3

		// 13获取文件扩展索引
		System.out.println(FilenameUtils.indexOfExtension("C:\\Users\\Administrator\\Downloads\\test00.png"));// 39

		// 14获取文件最后一个分隔符索引
		System.out.println(FilenameUtils.indexOfLastSeparator("C:\\Users\\Administrator\\Downloads\\test00.png"));// 32

		// 15判断文件扩展名是否符合给定的
		List<String> suffixList = new ArrayList<String>();
		suffixList.add("png");
		suffixList.add("txt");
		suffixList.add("xlsx");
		System.out.println(FilenameUtils.isExtension("C:\\Users\\Administrator\\Downloads\\test00.png", suffixList));// true

		// 16判断文件扩展名是否符合指定的
		System.out.println(FilenameUtils.isExtension("C:\\Users\\Administrator\\Downloads\\test00.png", "png")); // true

		// 17标准化文件路径
		System.out.println(FilenameUtils.normalize("C:\\Users\\Administrator\\Downloads\\test00.png")); // C:\Users\Administrator\Downloads\test00.png

		// 18标准化文件路径,不含最后的结尾分隔符
		System.out.println(FilenameUtils.normalizeNoEndSeparator("C:\\Users\\Administrator\\Downloads\\test00.png")); // C:\Users\Administrator\Downloads

		// 19获取不含后缀的文件路径和文件名
		System.out.println(FilenameUtils.removeExtension("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:\Users\Administrator\Downloads\test00

		// 20转换文件分隔符为系统分隔符
		System.out.println(FilenameUtils.separatorsToSystem("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:\Users\Administrator\Downloads\test00.png

		// 21转换文件分隔符为Unix系统分隔符
		System.out.println(FilenameUtils.separatorsToUnix("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:/Users/Administrator/Downloads/test00.png

		// 22转换文件分割符为windows系统分隔符
		System.out.println(FilenameUtils.separatorsToWindows("C:\\Users\\Administrator\\Downloads\\test00.png"));// C:\Users\Administrator\Downloads\test00.png

		// 23 判断文件名是否符合指定的规则
		System.out.println(FilenameUtils.wildcardMatch("C:\\Users\\Administrator\\Downloads\\test00.png", "*.png"));// true
	}

	public static void main(String[] args) throws Exception {
		FileInputStream fileInputStream1 = new FileInputStream("D:\\Test\\aa.txt");
		FileInputStream fileInputStream2 = new FileInputStream("D:\\Test\\bb.txt");
		FileOutputStream outputStream = new FileOutputStream("D:\\Test\\aa.txt");
		FileReader fileReader1 = new FileReader("D:\\Test\\aa.txt");
		FileReader fileReader2 = new FileReader("D:\\Test\\bb.txt");
		FileWriter fileWriter = new FileWriter("D:\\Test\\aa.txt");

		// 1静态变量
		// 1.1获取文件路径分隔符字符
		char dirSeparator = IOUtils.DIR_SEPARATOR;
		// 获取Unix系统文件路径分隔符字符
		char dirSeparatorUnix = IOUtils.DIR_SEPARATOR_UNIX;
		// 获取windows系统文件路径分隔符
		char didSeparatorWindows = IOUtils.DIR_SEPARATOR_WINDOWS;
		// 1.2获取行分隔符
		String lineSeparator = IOUtils.LINE_SEPARATOR;
		// 获取Unix系统行分隔符
		String lineSeparatorUnix = IOUtils.LINE_SEPARATOR_UNIX;
		// 获取windows系统行分隔符
		String lineSeparatorWindows = IOUtils.LINE_SEPARATOR_WINDOWS;

   //出错的
		// 2静态方法
		// 2.1获取输入流
		// 根据InputStream获取BufferedInputStream
//		BufferedInputStream bufferedInputStream = IOUtils.buffer(fileInputStream1);
//		// 根据outputStream获取BufferedOutputStream
//		BufferedOutputStream bufferedOutputStream = IOUtils.buffer(outputStream);
//		// 根据reader获取BufferedReader
//		BufferedReader bufferedReader = IOUtils.buffer(fileReader1);

		// 2.2按行读取数据
		// 从InputStream输入流中获取行数据
		List<String> lineContent = IOUtils.readLines(fileInputStream1, "UTF-8");
		// 从Reader输入流中获取行数据
		List<String> lineContent1 = IOUtils.readLines(fileReader1);

		// 2.3从输入流中获取字节数组数据
		// 从inputStream获取文件字节数组
		byte[] data = IOUtils.toByteArray(fileInputStream1);
		// 从reader获取文件字节数组,并指定编码
		byte[] data1 = IOUtils.toByteArray(fileReader1, "UTF-8");
		// 从url资源中获取文件字节数组
		byte[] data2 = IOUtils.toByteArray(new URI("www...."));

		// 2.4从输入流中获取字符数据
		// 从InputStream输入流获取字符数据
		char[] charData = IOUtils.toCharArray(fileInputStream1, "UTF-8");
		// 从reader输入流中获取字符数组
		char[] charData1 = IOUtils.toCharArray(fileReader1);

		// 2.5从输入流中获取字符串数据
		// 从InputStream输入流中获取字符串数据
		String stringData3 = IOUtils.toString(fileInputStream1, "UTF-8");
		// 从reader输入流中获取字符串数据
		String stringData4 = IOUtils.toString(fileReader1);
		// 从url中获取字符串数据
		String stringData5 = IOUtils.toString(new URI("www..."), "UTF-8");

		// 3写数据
		// 3.1将字节数组数据通过输出流写到文件
		// 将字节数组数据通过Writer写到文件,并指明编码
		IOUtils.write(data, fileWriter, "UTF-8");
		// 将字节数组数据通过outputStream写到文件
		IOUtils.write(charData, outputStream, "UTF-8");
		// 将字符数组数据通过writer写到文件
		IOUtils.write(charData, fileWriter);

		// 3.2 将字符串通过输出流写到文件
		// 将字符串数据通过OutpurStream输出流,写到文件
		IOUtils.write(stringData5, outputStream, "UTF-8");
		// 将字符串数据通过Writer输出流写到文件
		IOUtils.write(stringData5, fileWriter);

		// 3.3将集合数据通过输出流写到文件
		// 将集合数据通关outputStream输出流写到文件
		IOUtils.writeLines(lineContent, "UTF-8", outputStream, "UTF-8");
		// 将集合数据通过writer输出流写到文件
		IOUtils.writeLines(lineContent, "UTF-8", fileWriter);

		// 4.获取文件输入迭代器
		// 从inputStream输入流中获取行迭代器
		LineIterator lineIterator = IOUtils.lineIterator(fileInputStream1, "UTF-8");
		// 从Reader输入流中获取行迭代器
		LineIterator lineIterator1 = IOUtils.lineIterator(fileReader1);

		// 5复制文件
		// 复制文件输入流到输出流
		System.out.println(IOUtils.copy(fileInputStream1, outputStream));
		// 复制文件输入流到输出流,并设置缓冲大小
		System.out.println(IOUtils.copy(fileInputStream1, outputStream));
		// 复制InputStream文件到输出流Writer,并设置输出流编码
		IOUtils.copy(fileInputStream1, fileWriter, "UTF-8");
		// 复制reader文件到writer
		IOUtils.copy(fileReader1, fileWriter);
		// 从inputstream复制大文件到outputstream,文件大小超过2g
		IOUtils.copy(fileInputStream1, outputStream);
		// 从reader复制大文件到writer,文件大小超过2g
		IOUtils.copy(fileReader1, fileWriter);

		// 6IO流比较
		// 比较两个InputStream是否相等
		System.out.println(IOUtils.contentEquals(fileInputStream1, fileInputStream2));
		// 判断两个reader是否相等
		System.out.println(IOUtils.contentEquals(fileReader1, fileReader2));

	}

}
~~~











# Properties类

是一个可以完成持久化操作的集合，是Map集合的子类

一般用来做配置环境，会在文件中配置一些数据，我们是需要进行读取数据，最重要的就是读取数据



比如用来保存数据库的配置

步骤：在项目下建一个config文件夹，里面建一个文件（.properties）

因为是Map集合的子集，所以数据也是以键值对的形式存储

这里随便用数据举个例子

~~~pro
root=root
password=1234
driver=com.jdbc.mysql
~~~



读数据

~~~java
public static void main(String[] args) throws IOException{
    Properties per =new Properties();
    //将文件装载到集合中
    per.load(new FileInputStream("config/db.properties"));
    System.out.println(per);//得到数据了
    
    //获取单个数据
    String password =per.getProperty("password");
    String driver = per.getProperty("driver");
    
    //也可以遍历
    per.forEach((k,v)->System.out.println(k+":"+v))
}
~~~



写数据

~~~java
Properties per =new Properties();
//格式
per.setProperty("李小璐"，"贾乃亮");


//写入
//创建流
FileWriter fw = new FileWriter("config/db.properties");
per.store(fw,"info");//第二个参数是注释信息
fw.close
~~~

这个类会读写就行







前面写的三层架构学生管理系统，用来模拟数据库的txt文件不好操作。这里就可以使用这个properties文件来替代txt文件。这样可以直接在properties文件里手动的修改数据，并且可以直观的看到数据的存储