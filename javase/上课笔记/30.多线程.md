# 多线程

### 什么是进程？

当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源。
而一个进程又是由多个线程所组成的。

进程：可以理解为正在运行中的程序

### 什么是线程？

是进程的进一步划分，线程是基于进程的
线程是程序中的一个执行流，每个线程都有自己的专有寄存器(栈指针、程序计数器等)，但代码区是共享的，
即不同的线程可以执行同样的函数。





### 单线程与多线程的概念

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，
也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

多线程的好处：
可以提高CPU的利用率。在多线程程序中，一个线程必须等待的时候，CPU可以运行其它的线程而不是等待，
这样就大大提高了程序的效率。





### 实现多线程的三种方式

java5之前有两种方法：

1. 继承Thread类
2. 实现Runnable接口

两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。



java5以后有第三种方式：

3. 实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值





# 继承Thread类实现多线程

步骤：

1. 编写一个类，继承Thread类
2. 重写**run方法**
3. 将要执行的代码放到run方法中
4. 使用的时候，定义线程对象
5. 启动线程，**start方法**启动

正确启动线程是不能直接调用run方法的，应该调用从Thread类中继承过来的start方法才可以启动线程

注意：多次启动同一个线程是非法的。尤其是当线程已经结束执行后，不能再重新启动。如果重新启动同一个线程，运行时会报错的



例子：

~~~java
public class ThreadDemo1 {
    public static void main(String[] args) {
        //4.使用的时候，定义线程对象
        MyThread my1 = new MyThread("线程A");
        //5.启动线程，start方法启动
        my1.start();
        MyThread my2 = new MyThread("线程B");
        my2.start();
        MyThread my3 = new MyThread("线程C");
        my3.start();

        String str=new String("abc");

    }
}

//1.编写一个类，继承Thread类
class MyThread extends Thread {
    String name;

    public MyThread(String name) {
        this.name = name;
    }

    //2.重写run方法
    @Override
    public void run() {
        //3.将要执行的代码放到run方法中
        for (int i = 0; i < 10; i++) {
            System.out.println(name + i);
        }
    }
}
~~~



### 多线程原理+内存图解

![多线程内存图解](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3.png)

以前的都是一个一个方法压栈执行的，有顺序，先进后出，一个一个方法按顺序执行。但是在多线程中，只要执行了start方法，start方法是不会压栈执行的，同样在栈中开辟出新空间来执行线程，这个空间的线程的执行权限和main方法是一致的，这时线程和main方法是同时执行的，谁能抢占到cpu资源，谁就执行。其实main方法也是一个线程

比如：

~~~java
 public static void main(String[] args) {
        MyThread my1 = new MyThread("线程A");
        my1.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("main---" + i);
             System.out.println(new Scanner(System.in).next());
        }
        MyThread my2 = new MyThread("线程B");
        my2.start();
        MyThread my3 = new MyThread("线程C");
        my3.start();
    }
~~~

执行到my1的start后，main方法不会管start执行完了没有，会直接去执行for循环，这时my1的start方法也同时执行，而main方法会阻塞在第6行，所以线程b和线程c只会在main方法这行完for循环后才能运行。





### start方法和run方法的区别（面试题）

从之前的案例可以看出，我们是通过start方法来开启线程的，而线程执行的代码是run中的代码

如果直接调用run方法而不是调用start，是不存在多线程的，run方法只当一个普通方法执行。



1. start：用来启动线程，真正实现多线程运行。在主线程执行到start后，无需等待至run方法体执行完毕就能继续执行下面的代码。通过Thread的start方法来启动一个线程，这时线程是处于就绪状态的，并没有运行。之后通过此Thread调用run方法来完成此线程的运行操作的，这里run方法称为线程体，包含此线程要执行的内容，run方法结束，此线程终止。
2. run：调用run方法只会当作普通方法执行。主线程依旧是顺序执行，只有等run方法执行完毕，才能继续执行下面的代码。程序中还是只有主线程这一个线程，没有达到多线程运行的目的。





# 实现Runnable接口实现多线程

步骤：

1. 编写一个类，实现Runnable接口
2. 重写run方法
3. 编写run方法的方法体
4. 测试类中创建一个Thread类
5. 测试类中创建一个Runnable接口实例
6. 用Thread类的构造器将Runnable接口实例传入
7. 用Thread类的的start方法启动线程

启动线程，还是要借助Thread类

~~~java
public class RunnableDemo1 {
    public static void main(String[] args) {
        Runnable r = new RunnableImpl();
        Thread t = new Thread(r);
        t.start();
        Thread t1 = new Thread(r);
        t1.start();
        Thread t2 = new Thread(r);
        t2.start();
        Thread t3 = new Thread(r);
        t3.start();
    }
}

class RunnableImpl implements Runnable {
    @Override
    public void run() {
        int j = 0;
        for (int i = 0; i < 101; i++) {
            j += i;
        }
        //获得线程的名称
        System.out.println(Thread.currentThread().getName() + ":" + j);
    }
}
~~~

//结果就是四个线程互相抢占资源运行，顺序不确定

**注意**：这里使用同一个Runnable不是同一个线程，Thread使用start才是启动线程。Runnable只是传入线程要执行的线程体。



### 匿名内部类写法

练习：用Runnable设计线程，要求用匿名内部类完成对线程的启动的编写

功能体：完成一个指定层数的等腰三角形打印

~~~java
public static void main(String[] args) {
        Thread th = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 6; i++) {
                    for (int j = 6 - i; j > 0; j--) {
                        System.out.print(" ");
                    }
                    for (int k = 1; k <= 2 * i + 1; k++) {
                        System.out.print("*");
                    }
                    System.out.println();
                }
            }
        });
        th.start();
    }
~~~



### lambda表达式写法

~~~java
 public static void main(String[] args) {
        Thread th = new Thread(() -> {
            for (int i = 0; i < 6; i++) {
                for (int j = 6 - i; j > 0; j--) {
                    System.out.print(" ");
                }
                for (int k = 1; k <= 2 * i + 1; k++) {
                    System.out.print("*");
                }
                System.out.println();
            }
        });
        th.start();
    }
~~~





# Callable和Future创建线程

Callable是可以有返回值的



步骤：

1. 编写一个类实现Callable
2. 重写call方法
3. 将线程体写到call方法体中
4. 在测试类中创建Callable实现类的实例
5. 使用FutureTask类来包装Callable的实例
6. 使用Thread对象（构造器参数WieFutureTask）并启动线程
7. 使用get方法获得返回值

~~~java
public class CallableDemo1 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable c = new MyCallable();
        FutureTask<Integer> ft = new FutureTask<>(c);
        Thread th = new Thread(ft);
        th.start();
        System.out.println("返回值：" + ft.get());
    }
}

class MyCallable implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i <= 100; i++) {
            sum += i;
        }
        System.out.println(Thread.currentThread().getName() + ":" + sum);
        return sum;
    }
}
~~~

练习：匿名内部类和lambda表达式方式

匿名内部类：

~~~java
public static void main(String[] args) {
        new Thread(new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int sum = 0;
                for (int i = 0; i <= 100; i++) {
                    sum += i;
                }
                System.out.println(Thread.currentThread().getName() + ":" + sum);
                return sum;
            }
        })).start();

        new Thread(new FutureTask<Integer>(() -> {
            int sum = 0;
            for (int i = 0; i <= 100; i++) {
                sum += i;
            }
            System.out.println(Thread.currentThread().getName() + ":" + sum);
            return sum;
        }));
    }
~~~







# 三种创建线程方式的对比（面试题）

采用实现Runnable和Callable接口来创建线程：

优势是：

1. 线程类只是实现了接口，还可以继承其他类，拓展性好
2. 资源共享：在这种方法下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想

劣势是：

1. 编程稍微复杂，且如果要访问当前线程，必须使用Thread.currentThread方法获取



使用继承Thread类的方式创建多线程：

优势：

1. 编写简单，如果要访问当前线程，则无需使用Thread.currentThread方法，直接使用this即可获得当前线程。

劣势：

1. 线程类已继承了Thread类，不能再继承其他类了





### Thread与Runnable接口的区别（资源共享问题）

如果一个类继承Thread类，则不适合多个线程共享资源；而实现了Runnable接口，则可以方便的实现资源共享



案例：实现资源共享

继承Thread类：

~~~java
public class Test1 {
    public static void main(String[] args) {
        MyThread mt1=new MyThread();
        MyThread mt2=new MyThread();
        mt1.start();
        mt2.start();

    }
}

class MyThread extends Thread {
    private int ticket = 10;

    @Override
    public void run() {
        while (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
        }
    }
}
~~~

//每个线程都卖10张票



~~~java
public class Test1 {
    public static void main(String[] args) {
        //可以实现资源共享
        MyRunnable mr1 = new MyRunnable();
        Thread mt1 = new Thread(mr1);
        Thread mt2 = new Thread(mr1);
        Thread mt3 = new Thread(mr1);
        mt1.start();
        mt2.start();
        mt3.start();

    }
}

class MyRunnable implements Runnable {
    private int ticket = 10;

    @Override
    public void run() {
        while (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
        }
    }
}
~~~

//三个线程卖了10张票



**注意**：将Thread的ticket改为static的，运行起来看起来似乎是资源共享的。但这不是同一个问题，因为静态的变量是属于类的，肯定就是共享于每一个对象的，这样是不存在资源共享问题的。静态资源属于类，它就不属于任何对象，也不属于线程本身，也就不属于线程之间的资源共享。





# 线程的常用操作方法

![线程的常用方法](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png)



### 获取线程及线程名称

~~~java
public class Demo1 {
    public static void main(String[] args) {
        new Thread(new MyThread(), "线程A").start();
        new Thread(new MyThread(), "线程B").start();
        new Thread(new MyThread()).start();
        new Thread(new MyThread()).start();

        //主程序也是一个线程，线程的名称有区别：main
        System.out.println(Thread.currentThread().getName());
    }
}

class MyThread implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            //获取当前线程
            //如果没有给线程取名字，则系统会自动为其分配一个名字，Thread-x,x是从0开始的，如果取了名字则系统不会为其分配
            System.out.println(Thread.currentThread());
            //获取当前线程的名字
            System.out.println(Thread.currentThread().getName());
        }
    }
}
~~~

线程的名称一般在启动前设置，但也允许为已运行的线程设置名称，且允许有两个Thread对象有相同的名字，但为了清晰，不宜使用这种方式



### 判断线程是否启动

使用start方法后，线程处于就绪状态，等待cpu分配资源运行。

~~~java
public static void main(String[] args) {
        Thread th = new Thread(new MyThread());
    	//判断线程是否处于启动状态
        System.out.println(th.isAlive());
        th.start();
        System.out.println(th.isAlive());
    }
~~~



### 强制线程运行

使用join方法让一个线程强制运行，线程强制运行期间，其他线程无法运行，必须等待此线程完成之后才可以继续执行

~~~java
private static void test3() {
        Thread th = new Thread(new MyThread(), "线程A");
        th.start();

        //当main线程运行到10后，线程A强制运行，只有线程A运行完毕，main线程才会继续运行
        for (int i = 0; i < 50; i++) {
            if (i > 10) {
                try {
                    th.join();  //使用join方法强制线程运行，只有当th运行完成，其他线程才能继续运行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.println(Thread.currentThread().getName() + "运行-----" + i);
        }
    }
~~~



### 线程的休眠

sleep是让当前线程进入休眠状态，让出CPU资源，处于阻塞状态，但是不会释放锁，这点与wait不同

~~~java
private static void test4() {
        while (true) {
            try {
                Thread.sleep(1000);//毫秒值
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(LocalDateTime.now());
        }
    }
~~~



### 线程的中断

当一个线程运行时，另外**一个**线程可以直接通过interrupt方法中断运行状态

~~~java
public class Demo2 {
    public static void main(String[] args) {
        Thread th = new Thread(new MyThread2());
        th.start();
        try {
//            Thread.sleep(3000);
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        th.interrupt();
    }
}

class MyThread2 implements Runnable {
    @Override
    public void run() {
        System.out.println("1.执行run方法");
        try {
            Thread.sleep(2000);
            System.out.println("2.休眠完成");
        } catch (InterruptedException e) {
            System.out.println("3.休眠被终止");
            e.printStackTrace();
        }
        System.out.println("4.run方法执行完毕");
    }
}
~~~



### 后台线程

### 概述

- 有一种线程，它是在后台运行的，它的任务是为其他的线程提供服务，这种线程被称为“后台线程 ( Daemon Thread )“，又称为"守护线程“ 。JVM 的垃圾回收线程就是典型的后台线程。

### 特征

- 后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。



### 线程的优先级

1. 如果没有设置线程的优先级则默认是5，包括主线程
2. 线程的优先级最大是10，最小是1
3. 优先级大只代表优先执行的几率高，不是绝对优先

~~~java
public class Demo3 {
    public static void main(String[] args) {
        Thread th = new Thread(new Mythread2());
        //获取线程的优先级
        System.out.println(th.getPriority());
        //设置线程的优先级
        th.setPriority(10);
        System.out.println(th.getPriority());
    }
}

class Mythread2 implements Runnable {

    @Override
    public void run() {

    }
}
~~~

#### 练习：

一、设计一个线程操作类，要求产生三个线程对象，并可以分别设置三个线程的休眠时间：

线程A，休眠10秒

线程B，休眠20秒

线程C，休眠20秒

并用两种方式实现

~~~java
public class Demo4 {
    public static void main(String[] args) {
        Mythread3 mt1 = new Mythread3("线程A", 1000);
        Mythread3 mt2 = new Mythread3("线程B", 2000);
        Mythread3 mt3 = new Mythread3("线程C", 3000);
        mt1.start();
        mt2.start();
        mt3.start();

        Thread mt4 = new Thread(new MyRunnable1(1000), "线程A");
        Thread mt5 = new Thread(new MyRunnable1(2000), "线程B");
        Thread mt6 = new Thread(new MyRunnable1(3000), "线程C");
        mt4.start();
        mt5.start();
        mt6.start();

    }
}

//第一种方法：继承Thread类
class Mythread3 extends Thread {
    private long time;

    public Mythread3(String name, int time) {
        super(name);
        this.time = time;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "休眠了" + time + "毫秒");
    }
}

//第二种方法：实现Runnable接口
class MyRunnable1 implements Runnable {
    private long time;

    public MyRunnable1(int time) {
        this.time = time;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "休眠了" + time + "毫秒");
    }
}
~~~



二、设计一个程序，可以多线程去下载MP4到指定的目录



多个线程下载同一个MP4，使用实现Runnable的方法,使用字节缓冲流

~~~java
public class Demo5 {
    public static void main(String[] args) {
        String src = "E:\\java\\javase\\11.多线程\\01.上课视频\\01.线程和进程的区别.mp4";
        String des = "C:\\Users\\15524\\桌面\\01.线程和进程的区别.mp4";


        Runnable r = new MyRunnable(src, des);
        Thread th = new Thread(r, "线程A");
        Thread th2 = new Thread(r, "线程B");
        Thread th3 = new Thread(r, "线程C");
        th.start();
        th2.start();
        th3.start();


    }
}

class MyRunnable implements Runnable {
    private String src;
    private String des;

    public MyRunnable(String src, String des) {
        this.src = src;
        this.des = des;
    }

    @Override
    public void run() {
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));
             BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(des))) {
            byte[] b = new byte[1024];
            int len;
            while ((len = bis.read(b)) != -1) {
                bos.write(b, 0, len);
                System.out.println(Thread.currentThread().getName() + "正在传输文件");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
~~~



多个线程下载多个MP4，一个线程对应一个MP4，使用继承Thread实现，使用Commons-IO工具

~~~java
public class Demo6 {
    public static void main(String[] args) {
        MyThread4 mt = new MyThread4("E:\\java\\javase\\11.多线程\\01.上课视频\\01.线程和进程的区别.mp4", "C:/Users/15524/桌面/01.线程和进程的区别.mp4");
        MyThread4 mt2 = new MyThread4("E:\\java\\javase\\11.多线程\\01.上课视频\\02.单线程和多线程概念.mp4", "C:/Users/15524/桌面/02.单线程和多线程概念.mp4");
        MyThread4 mt3 = new MyThread4("E:\\java\\javase\\11.多线程\\01.上课视频\\03.继承Thread类实现多线程.mp4", "C:/Users/15524/桌面/03.继承Thread类实现多线程.mp4");
        mt.start();
        mt2.start();
        mt3.start();
    }
}

class MyThread4 extends Thread {
    private String src;
    private String des;

    public MyThread4(String src, String des) {
        this.src = src;
        this.des = des;
    }

    @Override
    public void run() {
        try {
            FileUtils.copyFile(new File(src), new File(des));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
~~~







# volatile关键字

## 5.1 概述

- volatile保证线程间的数据的可见性

## 5.2 什么叫做可见性

- 可见性又叫读写可见。即一个共享变量N，当有两个线程T1、T2同时获取了N的值，T1修改N的值，而T2读取N的值，可见性规范要求T2读取到的值必须是T1修改后的值。

## 5.3 Java内存模型（JMM）

- 每个线程创建时，JVM会为其创建一份私有的工作内存（栈空间），不同线程的工作内存之间不能直接互相访问。

- JMM规定所有的变量都存在主内存，主内存是共享内存区域，所有线程都可以访问。

- 线程对变量进行读写，会从主内存拷贝一份副本到自己的工作内存，操作完毕后刷新到主内存。所以，线程间的通信要通过主内存来实现。

- JMM内存模型的可见性是指，多线程访问主内存的某一个资源时，如果某一个线程在自己的工作内存中修改了该资源，并写回主内存，那么JMM内存模型应该要通知其他线程来从新获取最新的资源，来保证最新资源的可见性。

  ![image-20220808173800565](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)

  

## 5.4 举例

- 进入死循环

  ~~~ java
  package com.gec.创建线程.volatile用法;
  
  
  
  class FirstThread extends Thread{
  
      public volatile static boolean flag=true;
  
      @Override
      public void run() {
  
          while (flag){
  
          }
      }
  }
  
  public class MainTest {
  
      public static void main(String[] args) throws InterruptedException {
  
          FirstThread firstThread=new FirstThread();
          Thread t1=new Thread(firstThread);
          t1.start();
  
          Thread.sleep(200);
  
          FirstThread.flag=false;
  
  
      }
  }
  
  ~~~

- 添加volatile，跳出死循环

  ~~~ java
  package com.gec.创建线程.volatile用法;
  
  
  
  class FirstThread extends Thread{
  
      public  static boolean flag=true;
  
      @Override
      public void run() {
  
          while (flag){
  
          }
      }
  }
  
  public class MainTest {
  
      public static void main(String[] args) throws InterruptedException {
  
          FirstThread firstThread=new FirstThread();
          Thread t1=new Thread(firstThread);
          t1.start();
  
          Thread.sleep(200);
  
          FirstThread.flag=false;
  
  
      }
  }
  
  ~~~

# 







# 线程同步问题

一个多线程的程序，如果是通过Runnable接口实现的，则意味着类中的属性将被多个线程共享，那么这样一来就会造成一种问题，如果这多个线程要操作同一资源的时候就有可能出现资源的同步问题。例如下面的卖票的例子：

~~~java
public class Demo1 {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        Thread th = new Thread(mr, "窗口1");
        Thread th2 = new Thread(mr, "窗口2");
        Thread th3 = new Thread(mr, "窗口3");
        th.start();
        th2.start();
        th3.start();
    }
}

class MyRunnable implements Runnable {
    private int ticket = 10;

    @Override
    public void run() {
        while (ticket > 0) {
            if (ticket > 0) {
                try {
                    //模拟网络延迟或其他原因
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
            }
        }
    }
}
~~~

输出结果：三个三个结果输出，并且在最后1,2张会出现重复卖同一张票、卖出第0张、卖出负数的票

## ???重复卖出同一张票是如何造成的





原因：假设票只剩一张了，这时线程1进入到休眠，这时线程2判断也是能通过的，之后也进入睡眠，假设线程1,2都没醒，这时线程3判断成功而进入睡眠，这时当线程醒过来后，就会导致卖出负数的票的原因。



解决方案：使用同步锁，原理就是在线程都要进行的操作上加一把锁，有一个线程进入了操作，那么就会锁上，其他线程无法进入，只能等待。通过牺牲效率来解决同步问题。

同步的原理：
1.没有锁的线程，不能进入同步，在同步中的线程，不出去则不会释放锁
2.同步对象，对象是任意的
3.同步锁要确保对象的唯一性
4.同步锁，有些叫对象监视器
5.原理：线程遇到同步代码块后，线程要判断同步锁释放存在，如果存在，则获取锁，执行同步代码块中的功能，如果不存在，则等待，直到获取锁后才可以执行

有两种解决方式

一、将需要同步的代码块设置为同步代码块

~~~java
class MyRunnable implements Runnable {
    private int ticket = 10;

    @Override
    public void run() {
        while (ticket > 0) {
            synchronized (this) {	//同步代码块，this是同步锁
                if (ticket > 0) {
                    try {
                        //模拟网络延迟或其他原因
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
                }
            }
        }
    }
}
~~~

使用同步之后的输出结果是一个一个输出的

这里的this就是同步锁，只有获取了锁才能执行操作并将其他线程阻塞。同步锁是任意的，可以用其他对象，比如可以在类属性中定义一个obj对象，用obj替换this也是同样的效果



二、将需要同步的代码块提取为一个方法，并用synchronized修饰方法

~~~java
class MyRunnable implements Runnable {
    private int ticket = 10;

    @Override
    public void run() {
        while (ticket > 0) {
            syntest();
        }
    }

    public synchronized void syntest() {	//将要运行的代码块提取为一个同步方法
        if (ticket > 0) {
            try {
                //模拟网络延迟或其他原因
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
        }
    }
}
~~~

练习：两个人A,B使用同一个账户，A在柜台取钱，B在ATM机取钱

~~~java
public class Demo2 {
    public static void main(String[] args) {
        MyRunnable2 mr = new MyRunnable2();
        Thread th1 = new Thread(mr, "A");
        Thread th2 = new Thread(mr, "B");
        th2.start();
        th1.start();
    }
}

class MyRunnable2 implements Runnable {
    private int money = 56;

    @Override
    public void run() {
        while (money > 0) {
            synchronized (this) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "取了1块钱,还剩" + money-- + "块");
            }
        }
    }
}
~~~





#### 问：同步方法有锁吗

有，同步方法中的锁是本类对象的引用this，

可以验证：将同步方法修改一下：(用卖票的例子)

~~~java
 public void syntest() {	
     synchronized (this){
        if (ticket > 0) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
        }
     }
    }
~~~

一样是可以运行的



#### 静态同步方法中有锁吗

有，但这时锁不是this了，因为静态的不属于对象，属于类，这时候锁是：本类类名.class

~~~java
 public static void syntest() {	
//     synchronized (this){	//this是不行的
        synchronized (MyRunnable.class){
        if (ticket > 0) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖了第" + ticket-- + "张票");
        }
     	}
    }
~~~



如果是使用继承Thread方式也有出现同步的情况，这种情况下的同步监视器就不一定是this，因为Runnable中子线程注入的都是同一个Runnable对象，执行run方法使用同步监视器的话都是同一个对象。但Thread中不同，看如下例子：

- **账号类**

  ~~~~ java
  public class Account
  {
  	// 封装账户编号、账户余额的两个成员变量
  	private String accountNo;
  	private double balance;
  	public Account(){}
  	// 构造器
  	public Account(String accountNo , double balance)
  	{
  		this.accountNo = accountNo;
  		this.balance = balance;
  	}
  	// 此处省略了accountNo和balance的setter和getter方法
  
  	// accountNo的setter和getter方法
  	public void setAccountNo(String accountNo)
  	{
  		this.accountNo = accountNo;
  	}
  	public String getAccountNo()
  	{
  		return this.accountNo;
  	}
  
  	// balance的setter和getter方法
  	public void setBalance(double balance)
  	{
  		this.balance = balance;
  	}
  	public double getBalance()
  	{
  		return this.balance;
  	}
  
  	// 下面两个方法根据accountNo来重写hashCode()和equals()方法
  	public int hashCode()
  	{
  		return accountNo.hashCode();
  	}
  	public boolean equals(Object obj)
  	{
  		if(this == obj)
  			return true;
  		if (obj !=null
  			&& obj.getClass() == Account.class)
  		{
  			Account target = (Account)obj;
  			return target.getAccountNo().equals(accountNo);
  		}
  		return false;
  	}
  }
  ~~~~

- **取钱的线程类**

  ~~~ java
  public class DrawThread extends Thread
  {
  	// 模拟用户账户
  	private Account account;
  	// 当前取钱线程所希望取的钱数
  	private double drawAmount;
  	public DrawThread(String name , Account account
  		, double drawAmount)
  	{
  		super(name);
  		this.account = account;
  		this.drawAmount = drawAmount;
  	}
  	// 当多条线程修改同一个共享数据时，将涉及数据安全问题。
  	public void run()
  	{
  		// 账户余额大于取钱数目
  		if (account.getBalance() >= drawAmount)
  		{
  			// 吐出钞票
  			System.out.println(getName()
  				+ "取钱成功！吐出钞票:" + drawAmount);
  			try
  			{
  				Thread.sleep(1);
  			}
  			catch (InterruptedException ex)
  			{
  				ex.printStackTrace();
  			}
  			// 修改余额
  			account.setBalance(account.getBalance() - drawAmount);
  			System.out.println("\t余额为: " + account.getBalance());
  		}
  		else
  		{
  			System.out.println(getName() + "取钱失败！余额不足！");
  		}
  	}
  }
  
  ~~~

- **主类**

  ~~~ java
  public class DrawTest
  {
  	public static void main(String[] args)
  	{
  		// 创建一个账户
  		Account acct = new Account("1234567" , 1000);
  		// 模拟两个线程对同一个账户取钱
  		new DrawThread("甲" , acct , 800).start();
  		new DrawThread("乙" , acct , 800).start();
  	}
  }
  ~~~



使用同步代码块

~~~java
public class DrawThread extends Thread
{
	// 模拟用户账户
	private Account account;
	// 当前取钱线程所希望取的钱数
	private double drawAmount;
	public DrawThread(String name , Account account
		, double drawAmount)
	{
		super(name);
		this.account = account;
		this.drawAmount = drawAmount;
	}
	// 当多条线程修改同一个共享数据时，将涉及数据安全问题。
	public void run()
	{
		// 使用account作为同步监视器，任何线程进入下面同步代码块之前，
		// 必须先获得对account账户的锁定——其他线程无法获得锁，也就无法修改它
		// 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑
		synchronized (account)
		{
			// 账户余额大于取钱数目
			if (account.getBalance() >= drawAmount)
			{
				// 吐出钞票
				System.out.println(getName()
					+ "取钱成功！吐出钞票:" + drawAmount);
				try
				{
					Thread.sleep(1);
				}
				catch (InterruptedException ex)
				{
					ex.printStackTrace();
				}
				// 修改余额
				account.setBalance(account.getBalance() - drawAmount);
				System.out.println("\t余额为: " + account.getBalance());
			}
			else
			{
				System.out.println(getName() + "取钱失败！余额不足！");
			}
		}
		// 同步代码块结束，该线程释放同步锁
	}
}
~~~

使用同步方法

因为使用this肯定不会是同一个对象，所以需要将执行的代码封装在另一个方法中，run方法去调用这个方法。这样同步方法的this才会是同一个

~~~java
/*
 * 定义一个Account账号类
 * */
class Account
{
	//账户名 
	private String accountName;
	//余额
	private double balance;
	
	public Account() {
		
	}

	public Account(String accountName, double balance) {
		this.accountName = accountName;
		this.balance = balance;
	}

	/**
	 * @return the accountName
	 */
	public String getAccountName() {
		return accountName;
	}

	/**
	 * @param accountName the accountName to set
	 */
	public void setAccountName(String accountName) {
		this.accountName = accountName;
	}

	/**
	 * @return the balance
	 */
	public double getBalance() {
		return balance;
	}

	/**
	 * @param balance the balance to set
	 */
	public void setBalance(double balance) {
		this.balance = balance;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "Account [accountName=" + accountName + ", balance=" + balance + "]";
	}
	
	/*
	 * 定义一个同步 方法
	 * 默认的同步监听器：this
	 * */
	public synchronized void drawMoney(double money)
	{
		if(this.getBalance()>=money)
		{
			//局部变量（每个线程分配一份m的变量存储）
			double m=this.getBalance()-money;
			
			//睡眠1秒
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			//account的balance属性才是共享变量值
			this.setBalance(m);
			
			System.out.println("账号名="+this.getAccountName()+" 取款金额="+money+"  当前余额="+this.getBalance()+" 线程id="+Thread.currentThread().getId()+"  m="+m);
		}else
		{
			System.out.println("账号名="+this.getAccountName()+"  余额不足，无法正常取款");
		}
	}
	
}


/*
 * 定义一个线程类：针对账号进行取款操作
 * */
class DrawThread extends Thread
{
	private Account account;
	private double money;

	public DrawThread(Account account,double money) {
		this.account = account;
		this.money=money;
	}
	
	@Override
	public void run() {
		account.drawMoney(money);
	}
	
}


public class MainTest {

	public static void main(String[] args) {
		
		//创建一个用户账号
		Account account=new Account("张三", 1000.00);
		
		DrawThread t1=new DrawThread(account, 800.00);
		DrawThread t2=new DrawThread(account, 200.00);
		t1.start();
		t2.start();

	}

}
~~~



总结：同步监听器对象

- 条件：必须是对象
- 条件：属于共享对象







# Lock接口

有的时候，synchronized关键字会显得过于沉重，不够灵活。synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。

这个时候Lock出现。

Lock不是Java中的关键字而是 java.util.concurrent.locks 包中的一个接口。下面我们简单介绍一下Lock接口。

Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。

Lock相对于synchronized关键字而言更加灵活，你可以自由得选择我你想要加锁的地方。当然更高的自由度也带来更多的责任。



#### 简介

- 从Java5开始，Java提供了一种功能更强大的线程同步机制-------通过显式定义同步锁对象来实现同
  步，在这种机制下，同步锁由Lock对象充当。Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的 Condition对象 。Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

#### 重入锁

-  ReentrantLock
   - 可重入锁ReentrantLock 是一个互斥锁，即同一时间只有一个线程能够获取锁定资源，执行锁定范围内的代码。这一点与synchronized 关键字十分相似。
   - ReentrantLock可重入锁，即：（lock/unlok）动作里面可以嵌套（lock/unlock），针对同一个锁可以多次嵌套使用，不会产生死锁。但是lock函数与unlock函数在代码中必须成对出现，否则会出现死锁。





注意：用Lock接口动态锁，好处，动态去获取和释放锁，获取锁和释放锁可以不用在一个方法中，也可以不用在一个代码块，之前讲的同步方法和同步代码块就只能在一个方法或者一个代码块中获取或释放锁

~~~java
public class Demo3 {
    public static void main(String[] args) {
        MyRunnable3 mr = new MyRunnable3();
        Thread th1 = new Thread(mr, "A");
        Thread th2 = new Thread(mr, "B");
        th2.start();
        th1.start();
    }
}

class MyRunnable3 implements Runnable {
    private int money = 56;

    private Lock lock = new ReentrantLock();	//new 一个lock

    @Override
    public void run() {
        while (money > 0) {
//            synchronized (this) {
            lock.lock();	//获取锁
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "取了1块钱,还剩" + money-- + "块");
//            }
            lock.unlock();//释放锁
        }
    }
}
~~~

在不同方法中

~~~java
class MyRunnable3 implements Runnable {
    private int money = 56;

    private Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (money > 0) {
            lock.lock();	//获取锁
            test();
        }
    }

    private void test() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "取了1块钱,还剩" + money-- + "块");
        lock.unlock();	//释放锁
    }
}
~~~





### 死锁

同步代码里面又嵌套同步，容易造成死锁，尽量避免编写这样的代码





# 线程的生命周期（面试题）

和操作系统相差不多



有5个状态

1. 新建：创建了一个线程对象
2. 就绪：线程对象创建后，调用了start方法，线程就处于就绪状态，此时线程位于可运行的线程池中，等待CPU的使用权
3. 运行：就绪状态的线程获取到了CPU的使用权，执行程序代码
4. 阻塞状态：线程由于某种原因放弃获取CPU使用权，暂时停止运行。直到恢复到就就绪状态，才继续等待CPU的使用权

​		阻塞分为三种：

​		4.1等待阻塞：执行wait方法，jvm将线程放入等待池，只有使用notify方法唤醒才能退出阻塞

​		4.2同步阻塞：因为同步锁而等待运行，也会进入等待池

​		4.3其他阻塞：执行sleep方法或有线程执行john方法或发出I/O请求，jvm会将其置为阻塞。当sleep超时或John线程终止或超时、或I/O处理完毕，线程重新进入就绪状态

5. 死亡状态：线程因执行完毕或因异常退出run方法，线程结束生命周期







# 如何结束线程

suspend方法：暂时挂起线程

resume方法：恢复挂起的线程

stop方法：停止线程



但是不推荐使用，这三个方法使用时具有固定的不安全性，运行时会产生死锁的问题



一般采取使用设置标志位的方式来结束线程

~~~java
public class Demo1 {
    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
        Thread th = new Thread(mr);
        th.start();
        try {
            th.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        mr.stop();	
    }
}

class MyRunnable implements Runnable {
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag) {
            System.out.println(Thread.currentThread().getName() + "执行了" + ++i + "次");
        }
    }

    //修改标志位
    public void stop() {
        this.flag = false;
    }
}
~~~





# 线程通信

## 传统的线程通信

可以借助于Object类提供的wait、notify、notifyall三个方法，这三个方法属于Object不属于Thread

这三个方法必须由同步监视器（synchronized）对象类调用（就是要用锁来调用）

​	如果在同步方法中，可以用this来调用这三个方法

​	如果在同步代码块中必须使用锁（就是synchronized括号内的对象）来调用三个方法



wait：使当前线程等待，直到其他线程调用同步监视器的notify方法唤醒该线程

notify：唤醒在此同步监视器上等待的单个线程

notifyAll:唤醒在此同步监视器上等待的所有线程



基本案例：

~~~java
public class Demo2 {
    public static void main(String[] args) {
        MyThread mt1 = new MyThread();
        mt1.start();
    }
}

class MyThread extends Thread {
    private Object obj = new Object();

    @Override
    public void run() {
        System.out.println("线程进入等待");
        try {
            obj.wait();		//不在同步监视器中，直接报错
            System.out.println("线程结束等待");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
~~~

~~~java
public class Demo2 {
    public static void main(String[] args) {
        Object obj = new Object();
        MyThread mt1 = new MyThread(obj);
        mt1.start();
        System.out.println("是否唤醒子线程？请输入Y");
        String str = new Scanner(System.in).next();
        synchronized (obj) {
            if (str.equals("Y")) {
                obj.notify();   //唤醒线程
            }
        }
    }
}

class MyThread extends Thread {
    private Object obj;

    public MyThread(Object obj) {
        this.obj = obj;
    }

    @Override
    public void run() {
        System.out.println("线程进入等待");
        synchronized (obj) {
            try {
                //wait依赖于同步监视器
                //一般只用在同步方法和同步代码块中
                obj.wait();
                System.out.println("线程结束等待");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
~~~



生产者消费者案例：生产者生产后，消费者消费，交替进行。

~~~java
public class Demo {
    public static void main(String[] args) {
        Info i = new Info(); // 实例化Info对象
        Producer pro = new Producer(i); // 实例化生产者，传递Info引用
        Consumer con = new Consumer(i); // 实例化消费者，传递Info引用

        new Thread(con).start(); // 启动消费者线程
        new Thread(pro).start(); // 启动生产者线程

    }
}

//公共资源类
class Info {
    private String name = "生产者："; // 信息名称，指定默认值
    private String content = "我生产OK"; // 信息内容，指定默认值
    private boolean flag = false; // 设置标志位

    public String getName() { // 取得信息名称
        return name; // 返回信息名称
    }

    public void setName(String name) { // 设置信息名称
        this.name = name; // 设置name属性内容
    }

    public String getContent() { // 取得信息内容
        return content; // 返回信息内容
    }

    public void setContent(String content) { // 设置信息内容
        this.content = content; // 设置content属性内容
    }

    public synchronized void set(String name, String content) { // 设置信息名称及内容
        try {
            if (!flag) { // 标志位为false，不可以生产
                this.wait(); // 等待消费者取走，处理异常
            }
            this.setName(name); // 设置信息名称
            this.setContent(content); // 设置信息内容
            flag = false; // 修改标志位，表示可以取走
            this.notify();
        } catch (Exception e) {
            // TODO: handle exception
        } // 唤醒等待线程
    }

    public synchronized void get() { // 取得信息内容
        try {
            if (flag) { // 标志位为true，不可以取走
                this.wait(); // 等待生产者生产，处理异常
            }
            Thread.sleep(600); // 加入延迟，处理异常
            System.out.println(this.getName() + " --> " + this.getContent()); // 输出信息
            flag = true; // 修改标志位为true，表示可以生产
            this.notify(); // 唤醒等待线程
        } catch (Exception e) {
            // TODO: handle exception
        }
    }

}

//消费者类
class Consumer implements Runnable {
    private Info info = null;            // 保存Info引用

    public Consumer(Info info) {            // 通过构造方法设置Info属性内容
        this.info = info;                // 为info属性初始化
    }

    public void run() {                // 覆写run()方法
        while (true) {
            try {
                Thread.sleep(100);    // 加入延迟
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            this.info.get();            // 取出信息
        }
    }
}

//生产者类
class Producer implements Runnable {
    private Info info = null; // 保存Info引用

    public Producer(Info info) { // 通过构造方法设置Info属性内容
        this.info = info; // 为info属性初始化
    }

    public void run() { // 覆写run()方法
        boolean flag = false; // 定义标记位
        while (true) {
            if (flag) { // 如果为true，则设置第一个信息
                this.info.set("生产者：", "我生产OK"); // 设置信息
                flag = false; // 修改标记位
            } else { // 如果为false，则设置第二个信息
                this.info.set("消费者：", "我消费完成"); // 设置信息
                flag = true; // 修改标记位
            }
        }
    }

}
~~~





## 使用Condition控制线程通信

### 2.3.1 概述

- 当使用 Lock 对象来保证同步时， Java 提供了一个 Condition 类来保持协调，使用 Condition 可以让那些已经得到 Lock 对象却无法继续执行的线程释放 Lock 对象 ， Condition 对象也可以唤醒其他处于等待的线程 。  

### 2.3.2 Condition的核心方法

- await（） : 类似于隐式同步监视器上的 wait（）方法，导致当前线程等待 ， 直到其他线程调用该 Condition
  的 signal（）方法或 signalAll（）方法来唤醒该线程 。
- signal（）: 唤醒在此Lock对象上等待的单个线程。如果所有线程都在该Lock对象上等待，则会
  选择唤醒其中一个线程。选择是任意性的。只有当前线程放弃对该Lock对象的锁定后(使用
  await方法) ，才可以执行被唤醒的线程。
- signalAll（）: 唤醒在此Lock对象上等待的所有线程。只有当前线程放弃对该 Lock 对象的锁定后，才可以执行被唤醒的线程。

### 2.3.3 上述实例修改成Condition实现

~~~ java
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

public class Account
{
	// 显式定义Lock对象
	private final Lock lock = new ReentrantLock();
	// 获得指定Lock对象对应的Condition
	private final Condition cond  = lock.newCondition();
	// 封装账户编号、账户余额的两个成员变量
	private String accountNo;
	private double balance;
	// 标识账户中是否已有存款的旗标
	private boolean flag = false;

	public Account(){}
	// 构造器
	public Account(String accountNo , double balance)
	{
		this.accountNo = accountNo;
		this.balance = balance;
	}

	// accountNo的setter和getter方法
	public void setAccountNo(String accountNo)
	{
		this.accountNo = accountNo;
	}
	public String getAccountNo()
	{
		return this.accountNo;
	}
	// 因此账户余额不允许随便修改，所以只为balance提供getter方法，
	public double getBalance()
	{
		return this.balance;
	}

	public void draw(double drawAmount)
	{
		// 加锁
		lock.lock();
		try
		{
			// 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞
			if (!flag)
			{
				cond.await();
			}
			else
			{
				// 执行取钱
				System.out.println(Thread.currentThread().getName()
					+ " 取钱:" +  drawAmount);
				balance -= drawAmount;
				System.out.println("账户余额为：" + balance);
				// 将标识账户是否已有存款的旗标设为false。
				flag = false;
				// 唤醒其他线程
				cond.signalAll();
			}
		}
		catch (InterruptedException ex)
		{
			ex.printStackTrace();
		}
		// 使用finally块来释放锁
		finally
		{
			lock.unlock();
		}
	}
	public void deposit(double depositAmount)
	{
		lock.lock();
		try
		{
			// 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞
			if (flag)             // ①
			{
				cond.await();
			}
			else
			{
				// 执行存款
				System.out.println(Thread.currentThread().getName()
					+ " 存款:" +  depositAmount);
				balance += depositAmount;
				System.out.println("账户余额为：" + balance);
				// 将表示账户是否已有存款的旗标设为true
				flag = true;
				// 唤醒其他线程
				cond.signalAll();
			}
		}
		catch (InterruptedException ex)
		{
			ex.printStackTrace();
		}
		// 使用finally块来释放锁
		finally
		{
			lock.unlock();
		}
	}

	// 下面两个方法根据accountNo来重写hashCode()和equals()方法
	public int hashCode()
	{
		return accountNo.hashCode();
	}
	public boolean equals(Object obj)
	{
		if(this == obj)
			return true;
		if (obj !=null
			&& obj.getClass() == Account.class)
		{
			Account target = (Account)obj;
			return target.getAccountNo().equals(accountNo);
		}
		return false;
	}
}
~~~

## 2.4 使用阻塞队列 (BlockingQueue) 控制线程通信

### 2.4.1 概述

- Java 5 提供了 一个 BlockingQueue 接口，虽然 BlockingQueue 也是 Queue 的子接口，但它的主要用
  途并不是作为容器，而是作为线程同步的工具 。 BlockingQueue 具有一个特征 : 当生产者线程试图向
  BlockingQueue 中放入元素时，如果该队列己满，则该线程被阻塞;当消费者线程试图从 BlockingQueue
  中取出元素时，如果该队列己 空， 则该线程被阻塞。

### 2.4.2 核心方法

- BlockingQueue 提供如下两个支持阻塞的方法。  
  - put(E e): 尝试把 E 元素放入 BlockingQueue 中，如果该队列的元素己满 ，则阻塞该线程。
  - take（）: 尝试从 BlockingQueue 的头部取出 元素，如果该队列的元素己空， 则阻塞该线程。

### 2.4.3 用法 

- 程序先定义一个大小为 2 的 BlockingQueue ， 程序先向该队列中放入两个元素，此时队列还没有满 ，两个元素都可以放入，因此使用 put（） 、 add（）、 offer（）方法效果完全一样 。   当程序试图放入第三
  个元素时 ，如果使用 putO方法尝试放入元素将会阻塞线程   

  ~~~ java
  package com.gec.阻塞队列;
  
  import java.util.concurrent.ArrayBlockingQueue;
  import java.util.concurrent.BlockingQueue;
  
  public class BlockingQueueTest {
  
      public static void main(String[] args) throws InterruptedException {
          // 定义一个长度为2的阻塞队列
          BlockingQueue<String> bq = new ArrayBlockingQueue<>(2);
          bq.put("Java"); // 与bq.add("Java"、bq.offer("Java")相同
          bq.put("Java"); // 与bq.add("Java"、bq.offer("Java")相同
          bq.put("Java"); // ① 阻塞线程。
      }
  }
  
  ~~~

### 2.4.4 生产者消费者实例

~~~ java
import java.util.concurrent.*;

class Producer extends Thread
{
	private BlockingQueue<String> bq;
	public Producer(BlockingQueue<String> bq)
	{
		this.bq = bq;
	}
	public void run()
	{
		String[] strArr = new String[]
		{
			"Java",
			"Struts",
			"Spring"
		};
		for (int i = 0 ; i < 999999999 ; i++ )
		{
			System.out.println(getName() + "生产者准备生产集合元素！");
			try
			{
				Thread.sleep(200);
				// 尝试放入元素，如果队列已满，线程被阻塞
				bq.put(strArr[i % 3]);
			}
			catch (Exception ex){ex.printStackTrace();}
			System.out.println(getName() + "生产完成：" + bq);
		}
	}
}
class Consumer extends Thread
{
	private BlockingQueue<String> bq;
	public Consumer(BlockingQueue<String> bq)
	{
		this.bq = bq;
	}
	public void run()
	{
		while(true)
		{
			System.out.println(getName() + "消费者准备消费集合元素！");
			try
			{
				Thread.sleep(200);
				// 尝试取出元素，如果队列已空，线程被阻塞
				bq.take();
			}
			catch (Exception ex){ex.printStackTrace();}
			System.out.println(getName() + "消费完成：" + bq);
		}
	}
}
public class BlockingQueueTest2
{
	public static void main(String[] args)
	{
		// 创建一个容量为1的BlockingQueue
		BlockingQueue<String> bq = new ArrayBlockingQueue<>(1);
		// 启动3条生产者线程
		new Producer(bq).start();
		new Producer(bq).start();
		new Producer(bq).start();
		// 启动一条消费者线程
		new Consumer(bq).start();
	}
}
~~~

# 





# 线程池

每个线程，在执行任务的时候都要有两个操作：启动线程，任务执行完了，要销毁线程

如果有很多线程，启动和销毁线程是会占用资源的，如果有很多个线程则会导致资源浪费

 

线程池和以后的数据库连接池原理一样。先创建几个线程在线程池中等待，有任务时就执行，没任务就在线程池等待，任务太多则任务等待。

 

线程池解决了线程在执行任务时，创建和销毁浪费的资源。





jdk1.5之前无线程池，由程序员自己实现

程序一开始的时候，就创建了多个线程，用ArrayList来存储，需要线程的时候就从集合中取出去执行任务



jdk1.5之后就不用自己写线程池了

### 创建线程池的方法

## ThreadPoolExecutor类

### 1.3.1 概述

- Executor[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列4个组 件构成。

### 1.3.2 分析构造器

![image-20220810105315235](E:/java/javase/%E7%AC%94%E8%AE%B0/%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)

- corePoolSize：线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态
- maximumPoolSize：线程池允许创建的最大线程数。简单理解，即核心线程都被占用，但还有任务要做，就创建非核心线程
- ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。
- keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。
- TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。
- runnableTaskQueue：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。
  - ArrayBlockingQueue;
  - LinkedBlockingQueue;
  - SynchronousQueue;

- handler：表示当拒绝处理任务时的策略，有以下四种取值：
  - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
  - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
  - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
  - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

### 内置线程池

#### 1.newFixedThreadPool

~~~java
public static ExecutorService newFixedThreadPool(int var0) {
        return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());
    }
~~~

~~~java
public static ExecutorService newFixedThreadPool(int var0, ThreadFactory var1) {
    return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var1);
}
~~~

固定大小的线程池，可以指定线程池的大小，该线程池corePoolSize和maximumPoolSize相等，阻塞队列使用的是LinkedBlockingQueue，大小为整数最大值。
该线程池中的线程数量始终不变，当有新任务提交时，线程池中有空闲线程则会立即执行，如果没有，则会暂存到阻塞队列。对于固定大小的线程池，不存在线程数量的变化。同时使用无界的LinkedBlockingQueue来存放执行的任务。当任务提交十分频繁的时候，LinkedBlockingQueue
迅速增大，存在着耗尽系统资源的问题。而且在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源，需要shutdown。



演示：

~~~java
public class NewFixedThreadPoolDemo1 {
    public static void main(String[] args) {
        //创建一个有指定线程个数的线程池
        ExecutorService es = Executors.newFixedThreadPool(3);//创建一个有3个线程的线程池

        //提交任务给线程执行
        //提交了6个任务
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        es.submit(new MyRunnable());
        //如果提交的任务数和线程数相等，这个线程池（其他线程池不知）会平均分配任务，一个线程执行一个。其他数量则随机
        
        //执行完任务之后，线程没有被销毁的
        
        //销毁线程池，一般不用，知道就行
        es.shutdown();
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "----执行任务");
    }
}
~~~



演示2：带有返回值的线程池

~~~java
public class NewFixedThreadPoolDemo2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建一个有指定线程个数的线程池
        ExecutorService es = Executors.newFixedThreadPool(3);//创建一个有3个线程的线程池

        Future<Integer> f = es.submit(new MyCallable(100));
        Integer i = f.get();
        System.out.println("返回值：" + i);
    }
}

class MyCallable implements Callable {
    private int number;

    public MyCallable(int number) {
        this.number = number;
    }

    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i <= number; i++) {
            sum += i;
        }
        return sum;
    }
}
~~~





#### 2.newSingleThreadExecutor

~~~java
public static ExecutorService newSingleThreadExecutor() {
        return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));
    }
~~~

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory var0) {
    return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0));
}
```

**单个线程线程池，只有一个线程的线程池**，阻塞队列使用的是LinkedBlockingQueue,若有多余的任务提交到线程池中，则会被暂存到阻塞队列，待空闲时再去执行。按照先入先出的顺序执行任务。



#### 3.newCachedThreadPool

~~~java
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());
    }
~~~

    public static ExecutorService newCachedThreadPool(ThreadFactory var0) {
        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), var0);
    }

缓存线程池，缓存的线程默认存活60秒（默认等待时间是60秒，如果60秒都还没有任务，则自动销毁）。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列，    他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。



#### 4.14.6.newScheduledThreadPool

~~~java
public static ScheduledExecutorService newScheduledThreadPool(int var0) {
        return new ScheduledThreadPoolExecutor(var0);
    }
~~~

    public static ScheduledExecutorService newScheduledThreadPool(int var0, ThreadFactory var1) {
        return new ScheduledThreadPoolExecutor(var0, var1);
    }

定时线程池，该线程池可用于周期性地去执行任务，通常用于周期性的同步数据。
scheduleAtFixedRate:是以固定的频率去执行任务，周期是指每次执行任务成功执行之间的间隔。
schedultWithFixedDelay:是以固定的延时去执行任务，延时是指上一次执行成功之后和下一次开始执行的之前的时间。









# ThreadLocal类应用

## 2.1 简介

- ThreadLocal为解决多线程程序的并发问题提供了一种新的思路，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

## 2.2 核心方法

```csharp
public T get() {} // 获取ThreadLocal在当前线程中保存的变量副本
public void set(T value) {} //用来设置当前线程中变量的副本
private T setInitialValue(){} // 设置初始值
```

## 2.3 举例

~~~ java
package ThreadLocal用法;

class MyRunnable implements Runnable {
    
	private int i = 0;
	
	//ThreadLocal默认初始化数据值0
    ThreadLocal<Integer> threadId = new ThreadLocal<Integer>() {

        @Override
        protected Integer initialValue() {
            return 0;
        }
    };

	@Override
	public void run() {

		for (int j = 0; j < 10; j++) {

			// i++
			//i++;
             //每个线程都有一份threadId变量的副本
             //针对副本+1操作
			threadId.set(threadId.get()+1);

			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			// i--
			//i--;
             //针对副本-1操作
			threadId.set(threadId.get()-1);

			System.out.println("thread id=" + Thread.currentThread().getId() + "  i=" + threadId.get());

		}

	}
}

public class MainTest {

	public static void main(String[] args) {

		MyRunnable r = new MyRunnable();

		// 创建线程一
		new Thread(r).start();
		// 创建线程二
		new Thread(r).start();

	}

}

~~~

