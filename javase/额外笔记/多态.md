# 多态

## 什么是多态

看下面的例子

~~~java
class CaoGao {
	public static void main(String[] args) {
		A aa=new A();
		B bb=new B();
		aa.f();
		bb.f();
		
		//能不能把B当做A看，面向对象里的继承反应的是现实中一般到特殊的关系
		//aa是父类是一般的，bb是子类是特殊的。例如，把aa看成动物，bb看成狗
		//狗可以继承动物的特性吧，狗可以作为动物的一个子类，不是因为狗继承了动物的特点
		//而是狗是动物的一个特殊的个体，也就是说子类是父类的一个特殊的个体
		//那子类是不是可以当成父类来看
		
		aa=bb;   //把bb的值赋给aa，把B当A看了
        //不能直接把父类引用直接赋给子类引用
		//bb=aa; //error  把A当B看了  把父类赋给子类，好比把狗当做动物来看了，所以不行
		
		aa.f();     //BBBB
	}
}

class A {
	public void f() {
		System.out.println("AAAAA");
	}
	
}

class B extends A{
	public void f() {
		System.out.println("BBBBB");
	}

}
~~~

aa.f();     输出BBBB    这就是多态，父类引用指向子类对象



多态：如果把子类的引用发送给父类的引用，这时通过父类的引用调用方法时调用的就是子类的方法了

同样的代码做了不同的事情



假设，现在有一个超类，它派生了很多子类，这样的叫一个类族。现在这个超类中有一个公有的f()方法，那么他的所有子类都继承了这个f()方法，如果要编写代码来实现调用整个族群的f()方法，并且要求在类族成员扩充后，代码不能变，依旧能将整个类族的f()方法调用，要怎么去编写。这个时候多态就很方便了，并且在编写好后，即使族群的成员扩充了，代码也不需更改。



## 多态的注意事项和实际应用示例

多态的优点：同一段代码做不同的事情

​						如：假设A类派生出B，B派生出C

​								试编写一个函数实现调用整个A类族所有对象的f方法

​								

大概感觉一下多态的用途

~~~java
class CaoGao {
	public static void main(String[] args) {
		A aa = new A();
		B bb = new B();
		C cc = new C();
		D dd = new D();

		g(aa);
		g(bb);
		g(cc);
		g(dd);

	}
	//不需要改变形参的类型，也不需要重复编写大量代码，并且不用重新编写代码（即类族改变后，代码依旧可以保持不变）
	public static void g(A aa) {    //通过简单的代码就解决了两个问题
		aa.f();						//1.无论当前时刻有多少个对象，都能全部输出
	}								//2.即使以后类族扩充了，代码也不需要改变（向后兼容）
}

class A {
	public void f() {
		System.out.println("AAAAA");
	}

}

class B extends A {
	public void f() {
		System.out.println("BBBBB");
	}

}

class C extends B {
	public void f() {
		System.out.println("CCCCC");
	}
}

class D extends C {
	public void f() {
		System.out.println("DDDDD");
	}
}
~~~







~~~java
class CaoGao {
	public static void main(String[] args) {
		A aa = new A();
		B bb = new B();
		
		//bb=aa;//error,	
		//不能直接赋值，那会有办法将父类的引用赋给子类吗？
		
		//1.强制转换  
		aa=bb;
		bb=(B)aa;   //没报错
		bb.f();     //编译没错，运行报错，并且报错的是19行。但如果前面加上aa=bb就正确
		
		//首先，错是因为aa是父类的，bb是子类的。父类不能当做子类看，即使进行了强制转换
		//那也只是语法上允许（所以编译能成功），但是没有实际含义，所以运行失败，但不能这
		//样去运行，因为不符合实际含义
		
		//那为什么加了aa=bb就行了
		//因为不加aa=bb，此时的aa指向的是父类的对象，既然是父类的对象，所以不能强制转换
		//成子类的对象。加了aa=bb之后，aa指向的是子类的对象，所以可以进行强制转换
		
		aa.f();
		
	}

}

class A {
	public void f() {
		System.out.println("AAAAA");
	}

}

class B extends A {
	public void f() {
		System.out.println("BBBBB");
	}

}
~~~

可以这样理解，引用和对象是一起转换的，如果只是单单转换引用就像基本数据类型的强制转换一样是可以运行的。但是父类的对象不能转换成子类的对象，是不能运行的。当父类引用指向了子类对象时，这时只是引用的类型需要转换，所以可以运行。父类引用指向子类对象后赋给子类引用时还是需要强制转换，按道理应该是可以自动转换，但还是要手动强转，可能是设计编译器的时候觉得这样不好，因为强转也不是单单用在一个地方。



~~~java
class CaoGao {
	public static void main(String[] args) {
		A aa = new A();
		B bb = new B();
		
		aa=bb;
		//aa.g();   //按道理推过来似乎可以，但error
		//为什么
		//之前实现过，将子类的引用赋给父类引用，这时父类引用可以调用子类从父类中继承的方法
		//那如果此时父类引用调用某个子类特有的方法，然后将另一个子类的引用赋给父类引用，那
		//这时就无法调用前面子类特有的方法，所以这时的父类引用不能调用子类特有的方法，只能
		//调用子类从父类继承的方法
		
		
	}

}

class A {
	public void f() {
		System.out.println("AAAAA");
	}

}

class B extends A {
	public void f() {
		System.out.println("BBBBB");
	}
	
	public void g() {
		System.out.println("GGGGG");
	}

}
~~~



### 多态的使用格式

1. 普通类

   父类 变量名=new 子类()；

2. 抽象类

   抽象类 变量名=new 抽象类子类()；

3. 接口

   接口 变量名=new 接口实现类()；



### 多态成员的特点（要在有同名的情况下使用）

成员编译时都是看父类有没有，没有编译失败。

运行时，成员变量看父类，运行结果是父类结果；成员方法看子类，运行结果是子类结果



### 小结：

1. 子类对象可以直接赋给父类引用，但父类对象**在任何情况下**都不可以**直接**赋给子类引用，因为子类是父类的一种，但父类不是子类的一种，或者讲”子类可以当做父类看待，但父类不可以当做子类看待。“

2. 通过父类引用只能访问子类对象从父类继承过来的成员

3. 通过父类引用不能访问子类对象所特有的成员

4. 父类引用永远不可能直接赋给子类使用

   4.1只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转换成子类引用

   4.2其他情况下不允许吧父类引用强制转换成子类引用，否则运行时会发生错误





### instanceof（比较运算符）

判断某个对象是否是指定的数据类型。要注意，学生的对象属于学生类，同时也属于人类

boolean b=对象 instanceof 数据类型



### 转型

1. 向上转型（自动），父类类型 变量名=new 子类类型();
2. 向下转型（强转)，子类类型 变量名=（子类类型）父类类型的变量；



## 多态的好处与弊端

当父类的引用指向子类对象时，就发生了向上转型，即把子类类型对象转成了父类类型。向上转型的好处是隐藏了子类类型，提高了代码的扩展性。

小结：

1.但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能，功能有限制。我什么时候使用向上转型：

当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。

2.什么时候使用向下转型

当要使用子类特有功能时，就需要使用向下转型。

​	

3.向下转型的好处：可以使用子类特有功能。

4.弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。



### 三大特征总结（面试题）

封装、继承、多态的作用：

封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式 关键字:private

继承：子类会自动拥有父类所有可继承的属性和方法。关键字：extends implements

多态：父类的引用，指向子类的对象。配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义。
